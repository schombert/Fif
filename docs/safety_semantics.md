# A Safe Semantics for C++

Schombert: 2011-11-1 draft

This document is a sketch of a relatively low-level language that a safe extension of C++ could be compiled into. The low-level nature of this language makes it easier to define and express the rules that make the language safe. The point of this is twofold. First, it can help clarify the details of the Safe C++ proposal and any future proposals in the same vein, as we can explain their rules and constructions by explaining how they would translate into this simpler language. Secondly, it helps illustrate how the implementation of the checks required by a safe extension to C++ could be done, which helps show the feasibility of such an extension (in addition to the existence of a safe extension in the Circle compiler).

This document is *not* a syntax proposal. I have intentionally used characters outside ASCII to make it practically impossible to try to merge the syntax as it is presented here into C++ in any way. The language presented here is intentionally verbose, far more verbose than any safe extension needs to be.

This document is also *not* a proposal about how the standard should explain any safe extension that is added to the language. This document does not attempt to provide a fully formal and rigorous definition of anything; it is an attempt to produce an explanation that is as unambiguous as possible while remaining as understandable as possible. Rigorous definitions of the ideas presented here can be found in the further reading section.

## The pseudo-language

The language described here is substantially simpler than C++. For example, it contains several types of pointer, but not references. It contains structures, but not member functions. Roughly, you can think of it as a kind of IR, like the sorts of restricted languages that your compiler turns your C++ code into in order to perform optimizations and other transformations before producing the final binaries. In this case, the point of the simplified language is to be able to define the rules governing the safety analyzer (the procedure that runs as part of compilation and rejects code that cannot be guaranteed to be safe) with less ambiguity in terms of the simpler language. If we agree that the rules of the simpler language are sufficient for safety (do not contain what generally goes by the name of "soundness holes"), then we have a way to argue that any proposal that can be defined in terms of them is also safe (by arguing that the lowering transformations do not introduce any new "soundness holes").

### General notes

The pseudo language is syntactically close to C with a number of further restrictions (and the addition of templates). First, it must be in SSA form (static single-assignment form): any variable must have at most one assignment to it. This means that Φ functions may be needed in the presence of certain control flow constructions, which will be discussed in detail in the appropriate sections. Additionally, user-defined data types (really, anything that is not a *simple value* as described below) may not appear as values (i.e. they may not be the type of a local variable or function argument). All such objects must be accessed through pointers, and thus the notation `x.y`, where `x` is a pointer to some structure with a member named `y` has been repurposed to mean the pointer to the `y` member of the structure that `x` points to.

Function calls may only be made with arguments that are the names of variables or constant values. For example, `f(x)` is allowed, and `f(5)` is allowed, but `f(g(5))` is not allowed. One exception to this is that trivial mathematical expressions are allowed as arguments to functions, purely for the convenience of the author. User-defined data types do not have member functions as such. Instead, what would be member functions in C++ are expressed as free functions taking a pointer to the type as their first parameter.

### Abbreviated syntax for expressing templates

This document will denote lists of template parameters with the following notation `⟪...⟫`. This notation will be used both for instances of the template and to mark declarations of templated types and functions (with the list appearing after their names in those cases). Keywords such as `typename` will be omitted, under the assumption that the use of the template parameters in this document will make their classification clear. The special ∥ symbol may also appear in the list of template parameters for a type or function definition, in the pattern `⟪...∥...⟫`. Any items following the ∥ symbol express constraints that are created by a function call or type instantiation. These constraints can take the form of expressions, much like a `restrict` clause, indicating the constraints that would be generated by that expression. Or the items in the list may directly denote lifetime or borrow constraints (as explained in more detail below). If there is a need for a `declval` in such a clause, `ε(T)` is used as a shorthand for `std::declval<T>()`. If a symbol is needed for the lifetime of this value, `ε(T§S)` introduces a new name for its lifetime, in this case `S`, which may participate in other constraints in the clause. These constraints do not impact template specialization/overload resolution (for reasons that will be explained later).

### Simple values

In the pseudo-language only the simplest of types can exist as values: integers of various sizes, enums, boolean values, and pointers (both traditional C pointers, still represented with the T* notation, and the new 𝓁ptr, 𝒹ptr, 𝓂ptr, and 𝓈ptr types introduced for the pseudo-language). Every other object can only occur as the target of a pointer of some type. Pointers are never dereferenced. Instead, `load` and `store` functions are used to describe moving simple values to and from pointers (and any such functions called on C pointers are considered unsafe, so it is the four new pointer types that are the focus of the analysis). If `x` is a pointer to a structure with a member `y`, then the expression `x.y` is effectively a pointer to the `y` member of the structure that `x` points to (of the same pointer type and lifetime parameter, if any, of the `x` pointer). 𝓁ptr and 𝒹ptr types are strictly local types: they may not be members of a structure or stored on the heap, so they are always attached to a specific variable name or returned from a function (where they will be immediately attached to a variable name).

The new pointer types will have the rules governing them described at length in subsequent sections, and their function is best understood in terms of those rules, not intuitively. However, here is the intuitive explanation anyways:

The 𝓁ptr⟪T⟫ and 𝒹ptr⟪T⟫ types (both take a single template argument, the type of object they point to) form a pair. These two types are unlike any type found in C++, as a variable declared as one of these pointer types may have its type changed in the course of compilation to the other type. An 𝓁ptr represents a pointer to an allocation that contains a live object, while a 𝒹ptr represents a pointer to an allocation containing a dead object (or to an allocation that has yet to have had an object created in it). It is only possible to flip an object from living to dead, or vice versa, via a function call if you use one of these pointer types as a parameter.

The 𝓂ptr⟪T, L⟫ type (template argument T is the type of object pointed to and L is a lifetime describing when it is safe to load values from the pointer, i.e. a lower bound on the lifetime of its target) is a pointer that can be used to modify the state of the object pointed to. Only one 𝓂ptr at a time may be used to access a particular object (and thus, as a bonus, all such pointers can be automatically marked `restrict`).

Finally, the 𝓈ptr⟪T, L⟫ type represents a possibly shared view of an object. Its template arguments have the same meaning as those for 𝓂ptr.

None of the new pointer types may hold the `nullptr` value. In terms of lowering C++ to this pseudo-language, you might think of them as what references are ultimately lowered into.

### Returning "by value"

To represent returning a structure "by value" in the pseudo-language, the function nominally returns void and takes a 𝒹ptr⟪...⟫ as a parameter. By the rules of 𝒹ptr consumption (not described in this section), the function is responsible for constructing a value in the location pointed to and starting the lifetime of the object. In the calling context, the compiler would convert the 𝒹ptr⟪...⟫ used in the function call into an 𝓁ptr⟪...⟫, thereby making the returned value available after the call has completed.

### Trivial destruction, moves, and construction

This document uses the terms "trivial constructor", "trivial destructor", and "trivial destructive move" in a way that isn't exactly the same as their conventional usage in C++. For this document, "trivial" means, ideally, "no externally observable side effects." Generously, that could be extended to include allocation and deallocation, but it cannot include things like locking or unlocking a mutex. For the semantics described in this document to work, these functions must, at the minimum, be trivial for the simple value types. Outside of that, a hypothetical implementer has a great deal of freedom in deciding how much "trivial" should cover. Most restrictively, functions lacking a user-supplied definition could be the only ones deemed "trivial". Or the language could go as far as allowing triviality to be asserted via some unsafe trait as the user desires (unsafe because triviality probably cannot be checked by the compiler).

## Lifetimes

A lifetime, individually, represents a particular piece of compile-time information. A lifetime is not a type, and not all types necessarily involve lifetimes. However, a lifetime may serve as a non-type template parameter for some types. We could possibly see something like `template <typename T, lifetime L>` in a C++ one day (arguments over syntax permitting).

### Lifetime and time

The *time* in lifetime does not refer to time passed during the execution of the program but rather to points in the abstract flow of execution as found in the description of the program. Since we have removed composite expressions from the pseudo-language, you can generally think of each textual line in the program as being one point in that execution. The lifetime of a variable is thus the literal lines of code where it is visible (except for 𝓁ptr and 𝒹ptr variables, which are alive at the points where the variable is visible *and* it is an 𝓁ptr). Of course, execution does not flow through a function linearly. Inside an `if` construction, the sequences of points along each branch are unrelated to each other (a point on one branch is neither *before* nor *after* another), but the branches themselves are both *after* the evaluation of the conditional and they are both *before* the first line of code after the `if` statement and any associated `else` block. There are no special sequencing rules for loops; execution is treated as proceeding exactly once in sequence through the body of the loop just as we treat any other block. Thus, for any given function body, there are finitely many possible paths from the first line of the function to its exit points.

### Lifetime constraints

The constraint `X≼Y` says that the lifetime X does not end after the lifetime Y. This means that, on any possible path of execution through a function, if a line falls within lifetime X then it also falls within lifetime Y. The lifetime of a particular variable can be named in a constraint by prefixing its name with `§`. For example, `§x≼§y` constrains the variable y to outlive the variable x. The symbol `𝕌` in a lifetime constraint expression stands for the maximal lifetime, one that covers the entire execution of the program. The symbol `∅` denotes the minimal lifetime, the one that covers *no* points in the program. The symbol `⅀` can be provided to a template when declaring a variable, and it stand for the lifetime of the variable being declared plus the lifetimes of any variables that are the result of a Φ statement involving it, directly or indirectly (see below for more on Φ statements). Another, less precise, way of looking at it is that it is the lifetime that covers where the variable and its value are accessible. If provided as part of a parameter to a function, it is the lifetime of the entire function body (when compiling the function) and the lifetime of the call site (when invoking it). If provided as part of the declaration of a member variable of a struct, it is in each instance of the struct the lifetime of that instance (you can think of this as adding an unnamed template parameter to the struct that is always ⅀ when the struct is instantiated). When inside a function, `§` followed by the name of the function is the lifetime that covers the entirety of the function's execution. The lifetime constraint relation is transitive and reflexive.

Lifetime constraints are added monotonically to the analysis, meaning that once a constraint has been added we never take it away. However, constraints are not retroactive. Once a constraint is added we only check that it remains satisfied for the remainder of the function. If a lifetime constraint would be violated (for example `§x≼§y` would be violated by the lifetime of `y` ending while `x` is still alive) the compiler will first try to satisfy it by ending the lifetime early of any variables on the left hand side of that constraint that it is free to, meaning that there are no conflicting constraints keeping them alive and their destructors are trivial (as defined above). Compilation fails only if the compiler is not able to insert the required destructor calls prior to the line adding the new constraint.

### Lifetimes and function calls

Within the body of a function, the named parameters live for the duration of the function call (for 𝓁ptr and 𝒹ptr parameters the *name* is always available during the function call, although the liveness depends on which type the pointer currently is). The lifetime of the parameters may not be shortened to satisfy constraints. The return value, which is denoted ℛ in lifetime constraints when it is necessary to refer to it, is always assumed to be alive on exiting the function. For any expressions contained in the function's constraint list, for example `⟪ ∥ ~T(ε(𝓁ptr⟪T⟫)) ⟫`, any constraints that would be generated by a evaluation of that expression are added upon starting analysis of the function. When finishing the analysis of a function, any lifetime constraints involving lifetimes within the function call should be "widened" by replacing those interior lifetimes with the lifetime of the function call. Many constraints will be rendered redundant by this process; the only remaining constraints will be those involving at least one lifetime either named in the function's constraints or involving the parameters or return values. All of these constraints must be contained in the constraint list (`⟪ ∥ ... ⟫`) that is part of the declaration of the function or generated by one of the expressions contained in that list (note that the automatic lifetime constraints described above for these items do not need to be explicitly included in the list). If any are missing, compilation fails.

At a call site to the function, all parameters passed to the function must be alive (except for 𝒹ptr variables, which must *not* be alive). At the call site, all lifetime constraints contained in the function's constraint list (`⟪ ∥ ... ⟫`) are added to any existing constraints in the calling function (substituting in the names of the variables passed as parameters and the name that the return value is assigned to as appropriate). If there are expression within the function's constraint list, any lifetime constraints that would be generated by the evaluation of those expressions are added. If these lifetime constraints are inconsistent with existing constraints, compilation fails.

An early return from a function can be modeled as a Φ statement (see below) of the variables returned.

### Lifetimes and `if`s

A minor implementation issue is that the analyzer must proceed down one branch of the if, work out the constraints arising from that branch, and then back up to the initial state and proceed down the other branch. Once this has been done, there will be two sets of constraints, one from each branch. These constraint sets are then merged at the point where the if construction ends. If this results in a constraint that is impossible to satisfy, compilation fails.

The more interesting aspect of if constructions is the Φ statements that they generate as part of putting the code into SSA form. A statement a = Φ(b,c) is how values b and c from the two branches of the if are merged with a result that depends on which branch was taken. The lifetime of the *value* a begins with the Φ statement while that of the values b and c end with it. An 𝓂ptr⟪T,A⟫ and 𝓂ptr⟪T,B⟫ with different lifetime parameters A and B may appear within a single Φ statement. The result is an 𝓂ptr⟪T,C⟫ with the additional lifetime constraints `C≼A` and `C≼B`. The same goes for merging 𝓈ptrs with a Φ statement. An 𝓁ptr and a 𝒹ptr may not be merged with a Φ statement. However, if such a merger would be written, the compiler first attempts to either make both 𝓁ptrs or make both 𝒹ptrs. The pointer type to produce is decided by taking the complementary type of the pointer before it went into the if construction. For example, the compiler would attempt to make a 𝒹ptr that was turned into an 𝓁ptr on one of the branches into an 𝓁ptr on both branches. This is done by inserting a call to the type's default constructor on the branch where it is dead or by inserting a call to its destructor on the branch where it is alive, as appropriate. If this cannot be done (for example, if the type has no default constructor or calling one of these functions would introduce constraints that cannot be satisfied), compilation fails.

### Lifetimes and loops

`for` loops can be defined in terms of `while` loops, and `while` loops can be defined with an `if` and a `do` loop, so essentially the task reduces to modeling `do` loops. The body of a `do` loop, and its conditional expression, can be modeled as a single block with a single backward branch at its end. This backward branch means that the beginning of that block may contain Φ statements, and because the block has not been analyzed yet, the template parameter lifetimes of 𝓂ptr and 𝓈ptr types for one of the merged values, or 𝓁ptr/𝒹ptr status, may not yet be known. To resolve this conundrum, the loop block must be analyzed twice. In the first pass the resulting type of the Φ statement is taken to be simply the type that is known prior to entering the loop (and the associated variable is marked as having its lifetime end). Safety analysis for the loop is then performed, and if successful we then know the previously unknown types for the Φ statement. Merging 𝓁ptr and 𝒹ptr types is relatively simple. As with if conditionals, we attempt to bring mismatched types into agreement by inserting default constructor or destructor calls to convert the 𝓁ptr or 𝒹ptr back to the same type, except that these calls must be inserted in a new block that control flow goes through only on the backward branch to the start of the loop. (This allows, for example, a 𝒹ptr that is the result of the Φ statement to be accessible as an 𝓁ptr in expressions that follow the loop. It also illustrates why the lifetime of variables declared in the loop does not automatically end with the loop.) The lifetime contained in the 𝓂ptr resulting from a Φ statement is a bit trickier. For the sake of discussion, let us assume the Φ statement is `a = Φ(b,c)` where b is of type 𝓂ptr⟪T,B⟫, c is of type 𝓂ptr⟪T,C⟫, and a is of type 𝓂ptr⟪T,A⟫ with b the variable from outside the loop. We define a lifetime L that is the intersection of the lifetime covering only the loop block and (the union of B and the lifetime of c), and we add the constraint L≼C. We also add constraints `A≼C` and `A≼B`. The same is done for Φ statements with 𝓈ptrs. Then, with the types resulting from the Φ statements fully defined and these new constraints added, we perform safety analysis of the loop block again. If the analysis remains successful, the loop is considered safe.

There may be 𝓁ptr or 𝒹ptrs defined within the body of the loop, representing local variables declared in that lexical scope. The conventional C++ approach would be to insert destructor calls for any 𝓁ptrs prior to taking the backwards branch. There is, however, a way to extend the lifetimes of these local values beyond the body of the loop if we wanted to allow the possibility of automatic lifetime extension beyond the body of the loop, which would be to insert those destructor calls only on the backwards branch, which would potentially allow an 𝓁ptr to escape the loop.

### Lifetimes ending simultaneously

It is possible for a collection of lifetime constraints to require two or more variables to end their lifetimes at the same point in the program. (Most trivially: `A≼B` and `B≼A`) If all members, or all but one member, of this collection have trivial destructors, the non-trivial destructor call may be placed first at the required point followed by the trivial destructor calls (in any order) and the analysis will treat the constraints as satisfied. If two or more members of the set have non-trivial destructors, then compilation fails.

## Borrows

In addition to lifetime constraints there is a second category of constraints that we refer to in this document as borrows. There are three kinds of borrow. First, there is the shared borrow. A shared borrow of y by x is written `x⊣y`. A mutable borrow of y by x is written `x⩤y`. Finally, a transitive borrow relation is written `x⫤y`. The borrow is said to be active if it is within the lifetime of the item on the left side of the expression, for generic values, or if the name on the left side remains accessible for 𝓁ptr and 𝒹ptr variables. The item on the left side of the relationship is called the source of the borrow while the object on the right side is called the target of the borrow.

When there is an active shared or mutable borrow on an 𝓂ptr, 𝓁ptr, or 𝒹ptr they are suppressed. A suppressed pointer may not be passed to any functions, nor can any derived pointer (i.e. if x is suppressed you can't pass x.y to a function with an 𝓂ptr argument). Additional shared borrows *can* be attached to a suppressed pointer, so if the 𝓂ptr to 𝓈ptr cast is modeled as a function, it must be the exception to the previous rule. An attempt to use a suppressed pointer causes compilation to fail. A 𝒹ptr that is the source of one or more mutable borrows becoming inaccessible (i.e. the scope the named variable was declared in ending) is also a constraint violation and also causes compilation to fail.

### Syntactic properties

All of the borrow constraints are transitive within their own class. In detail, Whenever a constraint of the form `x⊣y` is added to the analysis, additional constraints of the form `x⊣z` should also be added for each existing constraint of the form `y⊣z` and additional constraints of the form `z⊣y` should also be added for each existing constraint of the form `z⊣x`, and the same goes for ⩤ and ⫤. These constraints are also monotonic, meaning that once a borrow constraint has been added to the analysis, it is never removed. (But remember that a pointer is only suppressed when the values on the left hand side of a borrow constraint are alive.)

`x⫤y` also propagates both shared and mutable borrow constraints through it transitively. In particular: `a⊣b` and `b⫤c` generates `a⊣c`, `d⫤e` and `e⊣f` generates `d⊣f`, and so on.

### Exclusivity

Two active mutable borrows to the same target, or an active mutable borrow and one or more active shared borrows (from different variables than the mutable borrow -- a shared and mutable borrow on the same entity from the same entity is acceptable), are a constraint violation that causes compilation to fail.

### Borrows and members

Borrow constraints may exist between the members of an object on either, or both, sides of the constraint expression. `x⊣z` implies `x.y⊣z` for all members y of x. `a⊣b` implies `a⊣b.c` for all members c of b. The same rules also apply for mutable borrows and the transitive borrow relation. An active mutable borrow targeting an object as a whole is incompatible with a mutable borrow or shared borrow from another source on any member of the object because of the `a⩤b` to `a⩤b.c` implication and the exclusivity of mutable borrows on the same target.

An 𝓂ptr, 𝓁ptr, or 𝒹ptr to an object is suppressed if there is an active shared or mutable borrow on any of its members.

### Borrows and pointers

In many ways the interaction between borrow constraints and the content of pointers is much the same as that between such constraints and the content of containers, so the rules described here can also be used as a model for explicitly writing those constraints.

When pointer assignment a = b is made, it generates the constraint `a⊣b`, which means, given the transitive rule described above, that pointer a also suppresses, transitively, anything that b does. If a is an 𝓂ptr, 𝓁ptr, or 𝒹ptr, it also generates `a⩤b`. Finally, it also generates the transitive constraint `b⫤a`.

When a value, y, is stored into an 𝓈ptr pointer, x, the constraint `x⊣y` is generated. If that value is stored into an 𝓂ptr the constraint `x⩤y` is generated.

When a value, y, is loaded from an 𝓈ptr pointer, x, the constraints `y⊣x` and `x⫤y` are generated. If an 𝓂ptr value y is loaded from an 𝓂ptr the constraints `y⩤x` and `x⫤y` are generated (note that an 𝓂ptr cannot be loaded from an 𝓈ptr).

### Borrows and function calls

In most ways the rules for borrow constraints and function calls are similar to those for lifetime constraints. Namely: When finishing analysis of a function, any borrow constraints not involving the parameters and/or the return value should be discarded. All of the remaining borrow constraints must be contained in the constraint list (`⟪ ∥ ... ⟫`) that is part of the declaration of the function or be generated by one of the expressions contained in that list. If any are missing, compilation fails.

At a call site to the function, all borrow constraints contained in the function's constraint list (`⟪ ∥ ... ⟫`) are added to any existing constraints in the calling function (substituting in the names of the variables passed as parameters and the name that the return value is assigned to as appropriate). If there are expression within the function's constraint list, any borrow constraints that would be generated by the evaluation of those expressions are also added. At this point if the constraints are inconsistent (by violating exclusivity, for example), compilation fails.

An early return from a function can be modeled as a Φ statement (see below) of the variables returned.

### Borrows and `if`s

As with lifetime constraints, the constraints from the two branches of the `if` construction should be merged afterwards. If this results in inconsistent constraints, then compilation fails. For every Φ statement in the form `a = Φ(b,c)` the borrow constraints `a⫤b`, `a⫤c`, `b⫤a`, and `c⫤a` are generated (which basically just transfers the constraints from b and c to a, so this can also be done by copying all borrow constraints involving b and c and substituting a for b and c.

### Borrows and loops

As with lifetime constraints, the Φ statements at the beginning of the block that is the body of a loop are handled as part of the two passes that are already done for lifetime constraints. In the first pass they are given just the transitive borrow constraints for the variable that comes from outside the loop. At the start of the second pass, any borrow constraints generated by the first pass for the variable in the loop are transferred to the variable that is the target of the Φ statement, and then all other borrow constraints from the first pass are discarded. If the second pass does not reveal any constraint violations, the loop passes the analysis.

### Note on semantic intent

The intent of borrow constraints is to express the existence of one or more "views" of a value. Mutable access to a value via a pointer that aliases one or more other pointers is a safety violation, and so suppression is intended to guarantee that this cannot happen by suppressing any such mutable access while a view is accessible. As with any such semantic rules, borrow constraints are overly restrictive. In particular, their monotonic nature typically means that once an object on the left side of a borrow relation is put into a container the suppression will remain in effect until the lifetime of the container itself ends (insertion into the container is expressed as the container borrowing the inserted value, which then makes the container transitively borrow everything that the value was borrowing).

## A fork in the road: do we need lifetime constraints?

There is a plausible rule that can be added to the above section: if `a⊣b` or `a⩤b` and b is not alive, then a is suppressed. This rule exists in the Safe C++ proposal and in Rust (as I understand it). If you admit this rule, then you may not need the ability to express lifetime constraints independently, as you could instead say that `a⊣b` generates `§a≼§b`. And once you have that rule, it is easy to extend the notation to work on lifetimes as well, letting `L⊣M` stand in for `L≼M`. This is very neat and simplifies the language. It also reduces the number of constraints you might have to write, since ⊣ now does the work of ≼ as well.

However, there is a serious drawback to this rule: it conflates an object being *able* to access something with actually accessing it. This isn't an issue in many cases. When a container or other object contains dead references, usually nothing is lost by disposing of the container at that point, since there isn't much that can be safely done with it. However, it makes the semantics of the destructor in particular almost impossible to express. To dispose of a container borrowing from dead objects, it must be legal to call the destructor with a pointer to the container, which the rule above would make impossible. To get around this, Safe C++ and Rust add a special unsafe escape hatch that allows annotating the destructor as a function that can ignore the rule in certain circumstances (essentially, by making an unchecked promise not to peek).

The rest of this document *does not* follow this fork. Instead it explores what the pseudo-language would look like without this compromise and what can be done to simplify it without adding the additional rule.

## Other pointer rules

### Pointer conversion

Pointers may be converted from one type to another (i.e. may be cast from one pointer type to another) safely given the following restrictions: 

| From         |    To          |  Constraints generated    | Other restrictions                                |
| ------------ | -------------- | ------------------------- | ------------------------------------------------- |
| 𝓁ptr⟪T⟫ x     |  𝓂ptr⟪U, L⟫ y | `L≼§x`, `y⩤x`, and `x⫤y` |  T is a subtype of U or T = U                     |
| 𝓁ptr⟪T⟫ x     |  𝓈ptr⟪U, L⟫ y  | `L≼§x` and `y⊣x`          |  T is a subtype of U or T = U                    |
| 𝓂ptr⟪T, L⟫ x |  𝓂ptr⟪U, M⟫ y | `M≼L`, `y⩤x`, and `x⫤y`  |  T is a subtype of U or T = U                     |
| 𝓂ptr⟪T, L⟫ x |  𝓈ptr⟪U, M⟫ y  | `M≼L` and `y⊣x`           | T is a subtype of U or T = U                     |
| 𝓈ptr⟪T, L⟫ x  |  𝓈ptr⟪U, M⟫ y  | `M≼L` and `y⊣x`           | T is a subtype of U or T = U                     |
| 𝓂ptr⟪T, L⟫ x |  𝓁ptr⟪T⟫ y     | `§y≼L`, `y⩤x`, and `x⫤y` | y must be an 𝓁ptr⟪T⟫ when it becomes inaccessible |

Additional note on casting and subtypes: Being able to cast to a parent type could potentially escape any constraints that the subtype imposes on certain states being impossible (the same goes for accessing members of a struct directly). Thus, in the pseudo-language as defined, all types must support being in any possible state. In a real language, this could be avoided by making members, and the parent type if necessary, private so that casting to the parent type/accessing members is impossible if some states of those objects are not supported by the type.

### Loads and stores

An 𝓂ptr cannot be loaded from an 𝓈ptr (and an 𝓁ptr definitely can't be, since they can't be stored at all). I emphasize this to start with because it is an important rule to remember when writing unsafe code that is "pointer like" in allowing the retrieval of some stored object: you should not be able to get an 𝓂ptr out without putting an 𝓂ptr to the containing object in (unless aliasing is being prevented at runtime via a mutex, for example). Secondly, remember that only simple values are *values* in this pseudo-language, so you cannot load a struct from a pointer; only loads from pointers to the struct's simple members are possible.

With those caveats, the general signature for `load` is `auto load⟪T, L ∥ ⅀≼L, ℛ⊣x, x⫤ℛ ⟫(𝓈ptr⟪T, L⟫ x) -> T` and `auto load⟪T, L ∥ ⅀≼L, ℛ⩤x, x⫤ℛ ⟫(𝓂ptr⟪T, L⟫ x) -> T`; the general signature for `store` is `void store⟪T, L ∥ ⅀≼L, x⩤v ⟫(𝓂ptr⟪T, L⟫ x, T v)`. If T is not a simple value, then it must be hidden behind a pointer, and thus there are no loads and stores for it directly. If the pseudo-language were a real language, the role would be filled with automatically generated copy constructor, copy assignment, and destructive move functions.

### 𝓁ptr and 𝒹ptr rules

The 𝓁ptr and 𝒹ptr types have some additional rules, beyond those already noted in this document. When an 𝓁ptr or 𝒹ptr is passed to a function call it is flipped to its complementary type (an 𝓁ptr becomes a 𝒹ptr, and vice versa) after that call. *Within* a function call, any 𝓁ptr and 𝒹ptr parameters must be flipped to their complementary types at all exits from the function. Any 𝓁ptr or 𝒹ptr variables declared within the function must be 𝒹ptr types when the variable stops being visible (generally, when the scope it was declared in ends). The compiler may achieve this by calling the destructor of those variables (in the standard destructor order that C++ normally guarantees), assuming that there are no active borrow constraints that would make that impossible (the compiler may be allowed to attempt to solve these constraint issues by recursively ending the lifetimes of the source of the constraints if possible). Likewise, the compiler may attempt to convert a 𝒹ptr into an 𝓁ptr by calling the appropriate default constructor if compilation would otherwise fail.

𝓁ptr and 𝒹ptr types are passed as parameters to express the semantics of constructors, destructors, and destructive moves. A 𝒹ptr is passed to a constructor and the object becomes live within it, while an 𝓁ptr is passed to a destructor to manage ending the object's lifetime. A destructive move takes both an 𝓁ptr and a 𝒹ptr parameter and simultaneously ends the lifetime of one object while starting that of the other.

Of course, this ultimately leaves us with the question of how 𝓁ptr and 𝒹ptr types are changed within such a function. And to answer that question we have to do away with a simplification that has been useful so far: for structs there are no 𝓁ptr and 𝒹ptr types as such. Rather, what we have been calling an 𝓁ptr or 𝒹ptr to a struct is really an aggregate of liveness tracking data tracking the liveness of each member individually (or, you could think of it as an aggregate of 𝓁ptr and 𝒹ptrs to the members of the struct -- but please don't implement it that way). What we have been calling an 𝓁ptr is really one of these types where all the members are marked as alive, and a 𝒹ptr is one where all the members are marked as dead. So, the solution to how an 𝓁ptr switches its type for a struct is: recursively. Each member's 𝒹ptr must be turned into an 𝓁ptr by calling a function consuming a 𝒹ptr (i.e. a constructor or value assignment) for each of its members. (And I assume that the compiler provides constructors, destructors, and destructive moves for the simple types that all structs must eventually reduce to).

I am unable to come up with a non-hideous syntax for a pointer to a struct that is partly alive and partly dead, and so have only provided the ability to talk about structs that are all alive or all dead in the pseudo-language, but this is not an intrinsic limitation of the semantics.

## Other notes

### Miscellaneous UB cleanup

UB must be eliminated from the safe subset. Much of that is already covered by the analysis rules that prevent errors in handling lifetimes, but there are still some corner cases that will need to be taken care of. Most notably, signed overflow for arithmetical operations. While the solution that Rust takes is to pretend that it crashes the program, although it can only enforce this in debug builds, it may be wiser to simply say that signed overflow is implementation defined in the context of Safe C++. At the very least, some data should be gathered demonstrating that the lost optimization potential is more than measurement noise.

### Exceptions

The pseudo-language is loudly silent on the matter of exceptions, which is because exceptions are complicated. Preliminary reflection suggests that if exceptions are to be supported in Safe C++, all safe functions that can throw will have to exhaustively list all the objects that they could throw (and thus a function that does not either catch or declare an exception type that some function it calls could possibly throw could be caught at compile time). This list of possibly thrown exceptions will have to be added to the type of all function pointers and function objects. Unsafe functions not marked as `noexcept` will have to be invisibly wrapped with some shim to catch any exceptions that they do throw and terminate the program. That done, an exception--caught or otherwise--could be analyzed as a forward branch from the throwing function to either the catch handlers or the exit of the containing function (as throwing an exception could then be translated into the pseudo-language as a function returning a variant type followed by a test for the type returned and the appropriate control flow based on that).

### Function types

A function type must include the safety constraints it generates, because it is only safe to cast from a function type that generates a strict superset of those constraints (a function that requires/generates more constraints cannot be called in place of one that requires/generates fewer). Without this limitation you get the famous Rust bug (still unsolved as of writing this document) https://github.com/rust-lang/rust/issues/25860 that arises because of not tracking the constraints (at least, according to the author of the report; I am not a Rust expert). Further notes on when it is safe to cast from one function to another are also found in the *Conversion between types differing only in lifetimes* section below.

### Type instantiation and implementations 

The pseudo-language involves a large number of template instantiations, and many types and functions that were not templates previously may need to become templates in order to accommodate additional lifetime parameters. A naive implementation in an existing compiler could produce very poor results as it would create large numbers of types and functions for different variations of lifetime parameters. Mitigating this relies on two observations. First, lifetime parameters only affect the safety analysis, they do not affect code generation. Thus, types and functions that vary only via lifetime parameters can resolve to the same code on the backend. Secondly, most types created in this way will have lifetimes that only make sense within the function being analyzed, and so could be discarded afterwards. This suggests an implementation strategy where, for the analysis pass, very lightweight types are created to perform the analysis that simply refer to the lifetime-less types they will ultimately resolve to and discarding those lightweight types after the analysis pass. Furthermore, once a function has been compiled once, any future instantiations that differ just by lifetime parameters need only to have the analysis pass run, and can refer to the results of the previous compilation for the generated code.

## Extensions and additional work

There are a number of areas that are obvious targets for improvements but which are not required for the semantics described here to function.

### Reducing pointer lifetime annotations

Because 𝓂ptr and 𝓈ptr types both require an additional lifetime parameter, and this makes working with them verbose, it is desirable to hide that lifetime parameter as much as possible. The obvious choice is to default them to ⅀, which would require the object that is the pointer's target to live as long as the pointer variable (or the structure that the pointer is contained in, for member variables). This choice, however, may lead to things such as `[[unsafe::drop_only(T)]]` and the `__phantom_data` type (as described in the Safe C++ proposal) being necessary, as it becomes hard to describe using the pointer value (to call its trivial destructor) without the necessity of using the object pointed to, a situation in which the lifetime of the pointer variable is longer than the lifetime of the target. As illustrated in examples below, the verbose syntax here can be used by the analyzer deduce that such operations are safe without additional annotations. But, as also illustrated by the examples below, ⅀ is usually what is given to these lifetime parameters when not writing generic function parameters.

### Conversion between types differing only in lifetimes

Adding lifetime parameters to types generally produces the need for more function templates. Instead of a function taking a 𝓈ptr⟪vector⟪𝓈ptr⟪int⟫⟫⟫ parameter (a pointer to a vector of pointers to ints), you might instead find yourself writing a function that takes a 𝓈ptr⟪vector⟪𝓈ptr⟪int, F⟫⟫, ⅀⟫. The ⅀ (the lifetime of the function) is ugly, but isn't too bad, and may even be deduced (for example, as described above). In any case, it doesn't require a template. But the F in that type does, because it is a generic lifetime parameter. Now, what you really need for the function is maybe only an 𝓈ptr⟪vector⟪𝓈ptr⟪int, ⅀⟫⟫, ⅀⟫: a vector of pointers to integers that themselves are alive during the function call, which would not require a template. However, a vector⟪𝓈ptr⟪int, ⅀⟫⟫ is very specific, and the vectors you have at the call site are unlikely to contain pointers that live exactly as long as the function call, which is what the parameter requires.

There are a few possible fixes for this. You could add overloaded constructors to vector specifically for vectors that contain pointers to allow converting a vector containing longer lived pointers to one containing shorter lived pointers automatically. Unfortunately, this has the dual drawbacks of possibly creating additional temporary vectors *and* that it won't extend to vectors storing non-pointer types with lifetime parameters (string_views, for example).

We might consider a language extension, saying that types with longer lifetimes should be considered super-types of those with shorter lifetimes, thus allowing a 𝓈ptr⟪vector⟪𝓈ptr⟪int, F⟫⟫, ⅀⟫ to be treated as a 𝓈ptr⟪vector⟪𝓈ptr⟪int, ⅀⟫⟫, ⅀⟫ if F outlives the function. While this is a very nice solution, it doesn't always work. If you have a function⟪𝓈ptr⟪int, A⟫(𝓈ptr⟪int, B⟫)⟫ you can't substitute a function⟪𝓈ptr⟪int, C⟫(𝓈ptr⟪int, D⟫)⟫ for it if C and D outlive A and B. It works fine for the return type, but breaks for the parameter. If you call a function⟪𝓈ptr⟪int, A⟫(𝓈ptr⟪int, B⟫)⟫ you only have to provide it with a parameter that outlives B. However, if this call site is ultimately passed a function⟪𝓈ptr⟪int, C⟫(𝓈ptr⟪int, D⟫)⟫, that function is only safe if its parameter lives as long as D, which is longer than B. Thus, calling it with a parameter that only lives as long as B is unsafe, and so the type conversion that permitted this is unsafe.

Rust ultimately goes with the above approach by adding additional rules to the language about how, in their terms, lifetimes are deduced to be either co- or contra- variant. C++ has other options. We are already familiar in C++ with defining specialized constructors to define the set of legal conversions. That pattern could be extended here if we could avoid making the pointer type to pointer type cast (i.e. the reference type to reference type cast in the un-lowered language) require an unnecessary copy. This could be done either by some other type of annotation within class definitions indicating such safe conversions, or a syntax could be introduced for a function that converts the type of a pointer parameter and use that syntax to define the action of such safe conversion (there is already something like this in the pseudo-language given how a function call can change an 𝓁ptr to a 𝒹ptr, but it would need to be extended).

With that in place, a container such as vector could be written to define its in-place / direct-pointer conversions that extend the naively provided pointer-to-pointer cast logic as something like: `in_place_conversion: vector⟪T⟫ -> vector⟪U⟫ requires( in_place_convertible⟪T, U⟫ );`. Verbose, but is expressive enough to cover a very wide range of applications. (Note that in_place_convertible⟪T, U⟫ also requires T and U to be the same size, which holds for the cases we are talking about, but is more restrictive than being able to construct a U from a T.) 

### Automatic constraint deduction

The compiler knows the lifetime and borrow constraints that it needs to see in a function's ⟪ ∥ ... ⟫ list of constraints, which is why it can produce an error on compiling a function that cannot be guaranteed to be safe given their listed constraints. Thus, the compiler could equally well generate that list for us on compiling a function. Being able to type something like `auto` in that list could save *a lot* of annotating work. However, it also means that the compiler has to be able to see, and spend the time checking, the body of the function. Feasibility isn't obvious given the way that C++ compilers currently work. Yes, we could stuff every function into header files with inline, so this could be made to work, but it is actively fighting against the compilation process. In a better world, the compiler could analyze a .cpp file and save all the constraints it generates in the process somewhere for itself so that it can know what those constraints are in other places that use the function without us having to encode that information textually in the header file, which asks us not only to be manual scribes for information the computer is already able to figure out, but also invites the possibility of "dead" constraints -- those not actually needed by the function after changes to it -- persisting simply because changing the header files is forgotten or too much work.

### Better automatic lifetime extension

C++ contains some complex and easily misused rules about how binding to a reference may automatically extend the lifetime of certain objects. (I say easily misused based on the recent necessity of patching the standard to make it work for certain ranged for loops; there are probably other pitfalls still lurking.) Since the analysis essentially knows how long things need to live in order to make a function compile safely, the automatic lifetime extension rules could be simplified in Safe C++ to be essentially "as long as it has to live to make the function work".

### Making constexpr allocations easier

It would be useful to sometimes allow memory allocated during compilation as part of constexpr evaluation to be compiled into the program, while other such allocations definitely should not outlive the compilation process. Lifetime constraints give us a way to talk about and enforce that. By naming a lifetime that ends when compilation ends, it is possible to statically detect when a constexpr allocation is bound within that lifetime and when it may exceed it.

## Further reading:

Weiss, Aaron, Olek Gierczak, Daniel Patterson, and Amal Ahmed 2019 *Oxide: The Essence of Rust*
Karl Naden, Robert Bocchino, Jonathan Aldrich, Kevin Bierhoff 2012 *A type system for borrowing permissions*
Robert DeLine and Manuel Fähndrich 2004 *Typestates for Objects*
John Boyland 2003 *Checking Interference with Fractional Permissions*

## Examples

### Iterator invalidation

```
// prototypes of some functions used
auto to_iterator⟪T, L ∥ i⊣v, i≼L⟫(𝓈ptr⟪vector⟪T⟫, L⟫ v, 𝒹ptr⟪span_iterator⟪T⟫⟫ i) -> void;
auto empty(𝓈ptr⟪span_iterator⟪T⟫, ⅀⟫) -> bool;
auto advance(𝓂ptr⟪span_iterator⟪T⟫, ⅀⟫) -> void;
auto current⟪L ∥ ℛ⊣i, ℛ≼L⟫(𝓂ptr⟪span_iterator⟪T⟫, L⟫ i) -> optional⟪𝓈ptr⟪T, L⟫⟫;

auto emplace_back⟪T ∥ vec⩤val⟫(𝓂ptr⟪vector⟪T⟫, ⅀⟫ vec, 𝓁ptr⟪T⟫ val) -> void;
auto push_back⟪T ∥ vec⊣val⟫(𝓂ptr⟪vector⟪T⟫, ⅀⟫ vec, 𝓈ptr⟪T, ⅀⟫ val) -> void;

...

𝓂ptr⟪vector⟪int⟫, ⅀⟫ v = ...;                             // assume the vector is given to us
𝒹ptr⟪span_iterator⟪int⟫⟫ i = alloca⟪span_iterator⟪int⟫⟫();
to_iterator(v, i);                                        // constructs i, making it live 
                                                          // i⊣v, §i≼§v

while(!empty(i)) {
	auto it_result = current(i);                          // it_result⊣i, it_result⊣v
                                                          // §it_result≼§i, §it_result≼§v
	auto value_from_array = value_or(it_result, 0);
	if(load(value_from_array) % 2 == 0)                   // ok, type of pointer is 𝓈ptr⟪T, §i⟫ and i is alive
		push_back(v, 2);                                  // conflicts with i⊣v and it_result⊣v; compiler error
	advance(i);
}

```
This example also illustrates how important having a ranged for loop can be for clean and efficient safe code. Because the iterator may not have a valid position (e.g. it may have reached the end of its range or have been constructed with an empty range), a function that allows us to look at the current value cannot safely return a pointer unconditionally. It can return an optional, as the example above has assumed, which is only engaged when there is a value to look it. Or, it could take a function that it invokes with the view of the current object of the iterator only when one exists. Or the iterator could be rewritten to have a map-like function that it applies to all of its contents (if any). But no while loop can provide the guarantee that the iterator is in a valid state inside the loop. The compiler could, however, safely create a ranged for loop that uses an unsafe method internally to unconditionally access the view of the current item, assuming that it also generates a mutable borrow on the iterator for the duration of the loop, thus preventing us from meddling with the iterator, or anything it depends on, to invalidate it during the loop.

### Making a dangling reference

```
𝓂ptr⟪vector⟪string_view⟪⅀⟫⟫, ⅀⟫ v = ...;                  // assume the vector is given to us
                                                          // string views are asserted as being good as long as the vector
														  // is accessible through this reference
														  
𝒹ptr⟪string_view⟪⅀⟫⟫ sptr_a = "string literal";           // Details of constructing a string_view omitted
                                                          // but this ought to be fine, as the literal has a lifetime of 𝕌
														  // creates sptr_a⊣"string literal"
														  
push_back(v, sptr_a);									  // Being in the same scope, the lifetimes are the same for both
                                                          // variables. Thus the implicit cast to an 𝓈ptr passes analysis.
														  // creates v⊣sptr_a, v⊣"string literal"

{
	𝒹ptr⟪string⟫ string_value =  ...;                      // we assume the constructor for the string is run here
	𝒹ptr⟪string_view⟪⅀⟫⟫ sptr_b;
	string_view⟪⅀⟫(sptr_b, string_value);                  // constructs a view of the string
	                                                       // creates sptr_b⊣string_value
														   
	push_back(v, sptr_b);                                  // This line (should) fail to compile: the lifetime of sptr_b
	                                                       // is less than that of v, and so its ⅀ resolves to a shorter lifetime,
														   // and, if safe, the string_view type would not allow that cast
}
```

So, to even put a reference into the vector that could dangle, we must relax the lifetime restriction. We can do that maximally by requiring no lifetime at all.

```
𝓂ptr⟪vector⟪string_view⟪∅⟫⟫, ⅀⟫ v = ...;        	  
𝒹ptr⟪string_view⟪⅀⟫⟫ sptr_a = "string literal";           // creates sptr_a⊣"string literal"
push_back(v, sptr_a);									  // lifetime of sptr_a is greater than ∅, so this cast is possible
                                                          // creates v⊣sptr_a, v⊣"string literal"

{
	𝒹ptr⟪string⟫ string_value =  ...;                   
	𝒹ptr⟪string_view⟪⅀⟫⟫ sptr_b;
	string_view⟪⅀⟫(sptr_b, string_value);                  // constructs a view of the string
	                                                       // creates sptr_b⊣string_value
														   
	push_back(v, sptr_b);                                  // Now this line should compile because the lifetime of sptr_b
	                                                       // is also greater than ∅
														   // creates v⊣sptr_b, v⊣string_value
}

for(auto s : v) {                                          // because I don't want to write out iterator details again ...
                                                           // Note that the Safe C++ proposal would fail to compile the code here
														   // since v borrows from a dead object and so cannot be used.
														   
	print(s);                                              // This line (should) fail to compile. At some point to print character
	                                                       // data must be loaded from the string_view, which will generate the
														   // constraint that the lifetime of the data pointed to includes the
														   // function call, which ∅ does not satisfy.
}

```

### Tracking liveness

```
// prototypes of some functions used
auto get_contents⟪T, L ∥ ℛ⩤p⟫(𝓂ptr⟪box⟪T⟫, L⟫ p) -> 𝓂ptr⟪T, L⟫;
auto get_contents⟪T, L ∥ ℛ⊣p⟫(𝓈ptr⟪box⟪T⟫, L⟫ p) -> 𝓈ptr⟪T, L⟫;
auto move⟪T⟫(𝒹ptr⟪box⟪T⟫⟫, 𝓁ptr⟪box⟪T⟫⟫) -> void;

...

𝒹ptr⟪box⟪string⟫⟫ string_ptr;
get_contents(string_ptr);                 // compilation fails: 𝒹ptr cannot be cast to 𝓂ptr

𝒹ptr⟪string⟫ string_value =  ...;         // we assume the constructor for the string is run here
box⟪string⟫(string_ptr, string_value);    // constructor for box, string_ptr is now an 𝓁ptr
get_contents(string_ptr);                 // ok, 𝓁ptr can be cast to 𝓂ptr

𝒹ptr⟪box⟪string⟫⟫ new_string_ptr;
move(new_string_ptr, string_ptr);         // calls the "move" constructor, flips the 𝓁ptr and 𝒹ptr parameters

get_contents(string_ptr);                 // compilation fails: string_ptr is a 𝒹ptr again
```

### Trying to return a dangling reference

```
auto as_str(int x) -> 𝓈ptr⟪string, ⅀⟫ {
    𝒹ptr⟪string, ⅀⟫ s;
	std::to_string(s, x);	// converts s to type 𝓁ptr⟪string, ⅀⟫
							// (note that ⅀ in the declaration remains bound to the same lifetime value as before, 
							// which is the lifetime §s
	return s; 				// attempt to implicitly convert 𝓁ptr⟪string, ⅀⟫ to 𝓈ptr⟪string, §as_str⟫
							// this fails because ~string(s) must run before the function exits (see below)
}
```

```
auto as_str(int x) -> 𝓈ptr⟪string, ⅀⟫ {
    𝒹ptr⟪string, ⅀⟫ s;
	std::to_string(s, x);
	~string(s);				// this converts s back to type 𝒹ptr⟪string, ⅀⟫
	return s;				// there is no 𝒹ptr to 𝓈ptr cast, so this fails to compile
}
```

Ok, so let's try another way to get this pointer out.

```
auto as_str(int x) -> 𝓈ptr⟪string, ⅀⟫ {
    𝒹ptr⟪string, ⅀⟫ s;
	std::to_string(s, x);
	𝓈ptr⟪string, §as_str⟫ ret_value;		// the pointer we want to return
	ret_value = s;						// This is provisionally legal; s could live as long as the function
										// thus, it is converted to an 𝓈ptr⟪string, §as_str⟫
										// this creates the borrow constraint: ret_value⊣s
										
	~string(s);							// This fails because ret_value⊣s is active and suppresses s, so s is not available
	return ret_value;					// And if ret_value was not alive for the previous line, it could not be returned here
}
```

Even assuming that `auto as_str(int x) -> 𝓈ptr⟪string, ⅀⟫` could be made to compile, a function call such as `auto v = as_string(4);` wouldn't be very useful. The lifetime of the string pointed to by v would have expired before it could possibly be used. Thus, no function that does anything with strings could be called with v as a parameter. Any function that wants to view any of the values contained in the string object must either itself, or transitively, load values from that pointer (or derived member pointers, which will have the same lifetime). For example `auto print_str(𝓈ptr⟪string, ⅀⟫ x) -> void`, which might print a string to the console, requires that the string passed to it be alive at least as long as the function call itself. The return value of `as_str`, however, has only guaranteed that the returned pointer has lived as long as the function call that made it. By the time any subsequent statements are reached, its lifetime has expired, and thus it cannot be converted to 𝓈ptr⟪string, §print_str⟫ later because the lifetime §print_str is not constrained to fall within the time that §as_str guarantees.

So, what about trying to return something with a longer lifetime, like `auto as_str(int x) -> 𝓈ptr⟪string, 𝕌⟫`. Well, the results would be an 𝓈ptr to contents that live as long as the program does, so it will obviously be usable after the call. But, if we can't get an §as_str out in the obvious way, we certainly can't get something with a longer lifetime out. So, what if we do a double indirection? We make a mutable pointer to a pointer with a sufficiently long lifetime. Then, we store the pointer we want to get out in that mutable pointer, and it will be safely out of the way by the time ~string runs.

```
auto as_str⟪L⟫(𝓂ptr⟪𝓈ptr⟪string, L⟫, ⅀⟫ i, int x) -> void {
    𝒹ptr⟪string, ⅀⟫ s;
	std::to_string(s, x);
	𝓈ptr⟪string, L⟫ ret_value;	// we want to store this in i
	ret_value = s;				// This cast generates the L≼§s constraint
	                            // it also generates ret_value⊣s
	store(i, ret_value);		
	~string(s);					// s cannot be destroyed here because it is suppressed, but even ignoring that ...
}                               // at the end of compilation L≼§s is widened to L≼§as_str
                                // since this is not in the function's list of constraints, compilation would fail
```

Ok, so we can annotate our function with a constraint that would solve this: ⟪L∥L≼§as_str⟫

```
auto as_str⟪L ∥ L≼⅀⟫(𝓂ptr⟪𝓈ptr⟪string, L⟫, ⅀⟫ i, int x) -> void {
    𝒹ptr⟪string, ⅀⟫ s;
	std::to_string(s, x);
	𝓈ptr⟪string, L⟫ ret_value;	// we want to store this in i
	ret_value = s;				// generates the L≼§s constraint and ret_value⊣s
	store(i, ret_value);		// this propagates the borrow constraint ret_value⊣s resulting in i⊣s
	~string(s);					// thus s is suppressed and not be able to be used here in the destructor call
								// i must live as along as §as_str because it is a parameter, so compilation fails
}
```

But what if the type in this function didn't need a destructor call; if it were an int, for example? Well, in that case, the function could compile. *But* it still remains safe. It can only be used with an 𝓈ptr⟪string, L⟫ where L extends to at most the end of the function call. Thus, no safe loads from the pointer inside i are possible after the function has returned, and there is no risk of peeking at the memory of an expired local.

### Use of an array 

```
𝒹ptr⟪array⟪int, 3⟫, ⅀⟫ data;
array⟪int, 3⟫(data, 1, 2, 3); 						// constructor
𝓈ptr⟪array⟪int, 3⟫, ⅀⟫ view = data;       			// creates view⊣data
auto element_view = array⟪int, 3⟫.index(view, 0);	// creates element_view⊣view, element_view⊣data
array⟪int, 3⟫.push(data, 4);							// data is suppressed, compilation fails
return load(element_view);							// if the lifetimes of element_view and view had been
                                                    // ended to make the previous line compile, element_view
													// could not then be loaded
```

How the index function might be declared (assuming they crash on out of range indexes):
```
auto array⟪T, size⟫.index⟪L ∥ ℛ⊣a⟫(𝓈ptr⟪array⟪T, size⟫, L⟫ a, int i) -> 𝓈ptr⟪T, L⟫;
auto array⟪T, size⟫.index⟪L ∥ ℛ⩤a, a⫤ℛ⟫(𝓂ptr⟪array⟪T, size⟫, L⟫ a, int i) -> 𝓂ptr⟪T, L⟫;
```
Note that ℛ⊣a in the first prototype doesn't do anything by itself; an 𝓈ptr doesn't do anything when it suppresses another 𝓈ptr, nor does being suppressed block the usage of an 𝓈ptr. However, this propagates transitively, and is what ultimately generates the element_view⊣data constraint in the analysis above.

### One way to consume the contents of a box

```
auto box⟪T⟫.map⟪U⟫(𝓁ptr⟪box⟪T⟫⟫ self, fn⟪𝓁ptr⟪T⟫ -> U⟫ f) -> U { 
       // need a specialization for functions returning void as well, of course

	auto v = self.ptr    // self.ptr is assumed to be a C pointer here 
	auto pv = unsafe.cast⟪𝓁ptr⟪T⟫⟫(v);
	
	𝒹ptr⟪U⟫ result;
	result = f(pv);      // do the mapping -- ends lifetime of contained object, starts lifetime of result object
	
	usafe.free(v);
	unsafe.forget(self); // forget flips the 𝓁ptr to a 𝒹ptr without calling any destructors
	
	return result;
}
```