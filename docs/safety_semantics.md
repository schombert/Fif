# A Safe Semantics for C++

Schombert: 2024-11-3 draft ver. 3

This document is a sketch of a relatively low-level language that a safe extension of C++ could be compiled into. The low-level nature of this language makes it easier to define and express the rules that make the language safe. The point of this is twofold. First, it can help clarify the details of the Safe C++ proposal and any future proposals in the same vein, as we can explain their rules and constructions by explaining how they would translate into this simpler language. Secondly, it helps illustrate how the implementation of the checks required by a safe extension to C++ could be done, which helps show the feasibility of such an extension (in addition to the existence of a safe extension in the Circle compiler).

This document is *not* a syntax proposal. I have intentionally used characters outside ASCII to make it practically impossible to try to merge the syntax as it is presented here into C++ in any way. The language presented here is intentionally verbose, far more verbose than any safe extension needs to be.

This document is also *not* a proposal about how the standard should explain any safe extension that is added to the language. This document does not attempt to provide a fully formal and rigorous definition of anything; it is an attempt to produce an explanation that is as unambiguous as possible while remaining as understandable as possible. Rigorous definitions of the ideas presented here can be found in the further reading section.

## The pseudo-language

The language described here is substantially simpler than C++. For example, it contains several types of pointer, but not references. It contains structures, but not member functions. Roughly, you can think of it as a kind of IR, like the sorts of restricted languages that your compiler turns your C++ code into in order to perform optimizations and other transformations before producing the final binaries. In this case, the point of the simplified language is to be able to define the rules governing the safety analyzer (the procedure that runs as part of compilation and rejects code that cannot be guaranteed to be safe) with less ambiguity in terms of the simpler language. If we agree that the rules of the simpler language are sufficient for safety (do not contain what generally goes by the name of "soundness holes"), then we have a way to argue that any proposal that can be defined in terms of them is also safe (by arguing that the lowering transformations do not introduce any new "soundness holes").

### General notes

The pseudo language is syntactically close to C with a number of further restrictions (and the addition of templates). First, it must be in SSA form (static single-assignment form): any variable must have at most one assignment to it. This means that Î¦ functions may be needed in the presence of certain control flow constructions, which will be discussed in detail in the appropriate sections. Additionally, user-defined data types (really, anything that is not a *simple value* as described below) may not appear as values (i.e. they may not be the type of a local variable or function argument). All such objects must be accessed through pointers, and thus the notation `x.y`, where `x` is a pointer to some structure with a member named `y` has been repurposed to mean the pointer to the `y` member of the structure that `x` points to.

Function calls may only be made with arguments that are the names of variables or constant values. For example, `f(x)` is allowed, and `f(5)` is allowed, but `f(g(5))` is not allowed. One exception to this is that trivial mathematical expressions are allowed as arguments to functions, purely for the convenience of the author. User-defined data types do not have member functions as such. Instead, what would be member functions in C++ are expressed as free functions taking a pointer to the type as their first parameter.

### Abbreviated syntax for expressing templates

This document will denote lists of template parameters with the following notation `âŸª...âŸ«`. This notation will be used both for instances of the template and to mark declarations of templated types and functions (with the list appearing after their names in those cases). Keywords such as `typename` will be omitted, under the assumption that the use of the template parameters in this document will make their classification clear. The special âˆ¥ symbol may also appear in the list of template parameters for a type or function definition, in the pattern `âŸª...âˆ¥...âŸ«`. Any items following the âˆ¥ symbol express constraints that are created by a function call or type instantiation. These constraints can take the form of expressions, much like a `restrict` clause, indicating the constraints that would be generated by that expression. Or the items in the list may directly denote lifetime or borrow constraints (as explained in more detail below). If there is a need for a `declval` in such a clause, `Îµ(T)` is used as a shorthand for `std::declval<T>()`. If a symbol is needed for the lifetime of this value, `Îµ(TÂ§S)` introduces a new name for its lifetime, in this case `S`, which may participate in other constraints in the clause. These constraints do not impact template specialization/overload resolution (for reasons that will be explained later).

### Simple values

In the pseudo-language only the simplest of types can exist as values: integers of various sizes, enums, boolean values, and pointers (both traditional C pointers, still represented with the T* notation, and the new ğ“ptr, ğ’¹ptr, ğ“‚ptr, and ğ“ˆptr types introduced for the pseudo-language). Every other object can only occur as the target of a pointer of some type. Pointers are never dereferenced. Instead, `load` and `store` functions are used to describe moving simple values to and from pointers (and any such functions called on C pointers are considered unsafe, so it is the four new pointer types that are the focus of the analysis). If `x` is a pointer to a structure with a member `y`, then the expression `x.y` is effectively a pointer to the `y` member of the structure that `x` points to (of the same pointer type and lifetime parameter, if any, of the `x` pointer). ğ“ptr and ğ’¹ptr types are strictly local types: they may not be members of a structure or stored on the heap, so they are always attached to a specific variable name or returned from a function (where they will be immediately attached to a variable name).

The new pointer types will have the rules governing them described at length in subsequent sections, and their function is best understood in terms of those rules, not intuitively. However, here is the intuitive explanation anyways:

The ğ“ptrâŸªTâŸ« and ğ’¹ptrâŸªTâŸ« types (both take a single template argument, the type of object they point to) form a pair. These two types are unlike any type found in C++, as a variable declared as one of these pointer types may have its type changed in the course of compilation to the other type. An ğ“ptr represents a pointer to an allocation that contains a live object, while a ğ’¹ptr represents a pointer to an allocation containing a dead object (or to an allocation that has yet to have had an object created in it). It is only possible to flip an object from living to dead, or vice versa, via a function call if you use one of these pointer types as a parameter.

The ğ“‚ptrâŸªT, LâŸ« type (template argument T is the type of object pointed to and L is a lifetime describing when it is safe to load values from the pointer, i.e. a lower bound on the lifetime of its target) is a pointer that can be used to modify the state of the object pointed to. Only one ğ“‚ptr at a time may be used to access a particular object (and thus, as a bonus, all such pointers can be automatically marked `restrict`).

Finally, the ğ“ˆptrâŸªT, LâŸ« type represents a possibly shared view of an object. Its template arguments have the same meaning as those for ğ“‚ptr.

None of the new pointer types may hold the `nullptr` value. In terms of lowering C++ to this pseudo-language, you might think of them as what references are ultimately lowered into.

### Returning "by value"

To represent returning a structure "by value" in the pseudo-language, the function nominally returns void and takes a ğ’¹ptrâŸª...âŸ« as a parameter. By the rules of ğ’¹ptr consumption (not described in this section), the function is responsible for constructing a value in the location pointed to and starting the lifetime of the object. In the calling context, the compiler would convert the ğ’¹ptrâŸª...âŸ« used in the function call into an ğ“ptrâŸª...âŸ«, thereby making the returned value available after the call has completed. (This process is usually what returning a structure "by value" is compiled into.) When discussing specific functions in this document, this verbose form of "return by value" is used. However, sometimes it is necessary to speak generally about functions returning what *could* be a structure. In those cases it is left to the reader to transform the function in question into the form described above if necessary.

### Trivial destruction, moves, and construction

This document uses the terms "trivial constructor", "trivial destructor", and "trivial destructive move" in a way that isn't exactly the same as their conventional usage in C++. For this document, "trivial" means, ideally, "no externally observable side effects." Generously, that could be extended to include allocation and deallocation, but it cannot include things like locking or unlocking a mutex. For the semantics described in this document to work, these functions must, at the minimum, be trivial for the simple value types. Outside of that, a hypothetical implementer has a great deal of freedom in deciding how much "trivial" should cover. Most restrictively, functions lacking a user-supplied definition could be the only ones deemed "trivial". Or the language could go as far as allowing triviality to be asserted via some unsafe trait as the user desires (unsafe because triviality probably cannot be checked by the compiler).

## Lifetimes

A lifetime, individually, represents a particular piece of compile-time information. A lifetime is not a type, and not all types necessarily involve lifetimes. However, a lifetime may serve as a non-type template parameter for some types. We could possibly see something like `template <typename T, lifetime L>` in a C++ one day (arguments over syntax permitting).

### Lifetime and time

The *time* in lifetime does not refer to time passed during the execution of the program but rather to points in the abstract flow of execution as found in the description of the program. Since we have removed composite expressions from the pseudo-language, you can generally think of each textual line in the program as being one point in that execution. The lifetime of a variable is thus the literal lines of code where it is visible (except for ğ“ptr and ğ’¹ptr variables, which are alive at the points where the variable is visible *and* it is an ğ“ptr). Of course, execution does not flow through a function linearly. Inside an `if` construction, the sequences of points along each branch are unrelated to each other (a point on one branch is neither *before* nor *after* another), but the branches themselves are both *after* the evaluation of the conditional and they are both *before* the first line of code after the `if` statement and any associated `else` block. There are no special sequencing rules for loops; execution is treated as proceeding exactly once in sequence through the body of the loop just as we treat any other block. Thus, for any given function body, there are finitely many possible paths from the first line of the function to its exit points.

### Lifetime constraints

The constraint `Xâ‰¼Y` says that the lifetime X does not end after the lifetime Y. This means that, on any possible path of execution through a function, if a line falls within lifetime X then it also falls within lifetime Y. The lifetime of a particular variable can be named in a constraint by prefixing its name with `Â§`. For example, `Â§xâ‰¼Â§y` constrains the variable y to outlive the variable x. The symbol `ğ•Œ` in a lifetime constraint expression stands for the maximal lifetime, one that covers the entire execution of the program. The symbol `âˆ…` denotes the minimal lifetime, the one that covers *no* points in the program. The symbol `â…€` can be provided to a template when declaring a variable, and it stand for the lifetime of the variable being declared plus the lifetimes of any variables that are the result of a Î¦ statement involving it, directly or indirectly (see below for more on Î¦ statements). Another, less precise, way of looking at it is that it is the lifetime that covers where the variable and its value are accessible. If provided as part of a parameter to a function, it is the lifetime of the entire function body (when compiling the function) and the lifetime of the call site (when invoking it). If provided as part of the declaration of a member variable of a struct, it is in each instance of the struct the lifetime of that instance (you can think of this as adding an unnamed template parameter to the struct that is always â…€ when the struct is instantiated). When inside a function, `Â§` followed by the name of the function is the lifetime that covers the entirety of the function's execution. The lifetime constraint relation is transitive and reflexive.

Lifetime constraints are added monotonically to the analysis, meaning that once a constraint has been added we never take it away. However, constraints are not retroactive. Once a constraint is added we only check that it remains satisfied for the remainder of the function. If a lifetime constraint would be violated (for example `Â§xâ‰¼Â§y` would be violated by the lifetime of `y` ending while `x` is still alive) the compiler will first try to satisfy it by ending the lifetime early of any variables on the left hand side of that constraint that it is free to, meaning that there are no conflicting constraints keeping them alive and their destructors are trivial (as defined above). Compilation fails only if the compiler is not able to insert the required destructor calls prior to the line adding the new constraint.

### Lifetimes and function calls

Within the body of a function, the named parameters live for the duration of the function call (for ğ“ptr and ğ’¹ptr parameters the *name* is always available during the function call, although the liveness depends on which type the pointer currently is). The lifetime of the parameters may not be shortened to satisfy constraints. The return value, which is denoted â„› in lifetime constraints when it is necessary to refer to it, is always assumed to be alive on exiting the function. For any expressions contained in the function's constraint list, for example `âŸª âˆ¥ ~T(Îµ(ğ“ptrâŸªTâŸ«)) âŸ«`, any constraints that would be generated by a evaluation of that expression are added upon starting analysis of the function. When finishing the analysis of a function, any lifetime constraints involving lifetimes within the function call should be "widened" by replacing those interior lifetimes with the lifetime of the function call. Many constraints will be rendered redundant by this process; the only remaining constraints will be those involving at least one lifetime either named in the function's constraints or involving the parameters or return values. All of these constraints must be contained in the constraint list (`âŸª âˆ¥ ... âŸ«`) that is part of the declaration of the function or generated by one of the expressions contained in that list (note that the automatic lifetime constraints described above for these items do not need to be explicitly included in the list). If any are missing, compilation fails.

At a call site to the function, all parameters passed to the function must be alive (except for ğ’¹ptr variables, which must *not* be alive). At the call site, all lifetime constraints contained in the function's constraint list (`âŸª âˆ¥ ... âŸ«`) are added to any existing constraints in the calling function (substituting in the names of the variables passed as parameters and the name that the return value is assigned to as appropriate). If there are expression within the function's constraint list, any lifetime constraints that would be generated by the evaluation of those expressions are added. If these lifetime constraints are inconsistent with existing constraints, compilation fails.

An early return from a function can be modeled as a Î¦ statement (see below) of the variables returned.

### Lifetimes and `if`s

A minor implementation issue is that the analyzer must proceed down one branch of the if, work out the constraints arising from that branch, and then back up to the initial state and proceed down the other branch. Once this has been done, there will be two sets of constraints, one from each branch. These constraint sets are then merged at the point where the if construction ends. If this results in a constraint that is impossible to satisfy, compilation fails.

The more interesting aspect of if constructions is the Î¦ statements that they generate as part of putting the code into SSA form. A statement a = Î¦(b,c) is how values b and c from the two branches of the if are merged with a result that depends on which branch was taken. The lifetime of the *value* a begins with the Î¦ statement while that of the values b and c end with it. An ğ“‚ptrâŸªT,AâŸ« and ğ“‚ptrâŸªT,BâŸ« with different lifetime parameters A and B may appear within a single Î¦ statement. The result is an ğ“‚ptrâŸªT,CâŸ« with the additional lifetime constraints `Câ‰¼A` and `Câ‰¼B`. The same goes for merging ğ“ˆptrs with a Î¦ statement. An ğ“ptr and a ğ’¹ptr may not be merged with a Î¦ statement. However, if such a merger would be written, the compiler first attempts to either make both ğ“ptrs or make both ğ’¹ptrs. The pointer type to produce is decided by taking the complementary type of the pointer before it went into the if construction. For example, the compiler would attempt to make a ğ’¹ptr that was turned into an ğ“ptr on one of the branches into an ğ“ptr on both branches. This is done by inserting a call to the type's default constructor on the branch where it is dead or by inserting a call to its destructor on the branch where it is alive, as appropriate. If this cannot be done (for example, if the type has no default constructor or calling one of these functions would introduce constraints that cannot be satisfied), compilation fails.

### Lifetimes and loops

`for` loops can be defined in terms of `while` loops, and `while` loops can be defined with an `if` and a `do` loop, so essentially the task reduces to modeling `do` loops. The body of a `do` loop, and its conditional expression, can be modeled as a single block with a single backward branch at its end. This backward branch means that the beginning of that block may contain Î¦ statements, and because the block has not been analyzed yet, the template parameter lifetimes of ğ“‚ptr and ğ“ˆptr types for one of the merged values, or ğ“ptr/ğ’¹ptr status, may not yet be known. To resolve this conundrum, the loop block must be analyzed twice. In the first pass the resulting type of the Î¦ statement is taken to be simply the type that is known prior to entering the loop (and the associated variable is marked as having its lifetime end). Safety analysis for the loop is then performed, and if successful we then know the previously unknown types for the Î¦ statement. Merging ğ“ptr and ğ’¹ptr types is relatively simple. As with if conditionals, we attempt to bring mismatched types into agreement by inserting default constructor or destructor calls to convert the ğ“ptr or ğ’¹ptr back to the same type, except that these calls must be inserted in a new block that control flow goes through only on the backward branch to the start of the loop. (This allows, for example, a ğ’¹ptr that is the result of the Î¦ statement to be accessible as an ğ“ptr in expressions that follow the loop. It also illustrates why the lifetime of variables declared in the loop does not automatically end with the loop.) The lifetime contained in the ğ“‚ptr resulting from a Î¦ statement is a bit trickier. For the sake of discussion, let us assume the Î¦ statement is `a = Î¦(b,c)` where b is of type ğ“‚ptrâŸªT,BâŸ«, c is of type ğ“‚ptrâŸªT,CâŸ«, and a is of type ğ“‚ptrâŸªT,AâŸ« with b the variable from outside the loop. We define a lifetime L that is the intersection of the lifetime covering only the loop block and (the union of B and the lifetime of c), and we add the constraint Lâ‰¼C. We also add constraints `Aâ‰¼C` and `Aâ‰¼B`. The same is done for Î¦ statements with ğ“ˆptrs. Then, with the types resulting from the Î¦ statements fully defined and these new constraints added, we perform safety analysis of the loop block again. If the analysis remains successful, the loop is considered safe.

There may be ğ“ptr or ğ’¹ptrs defined within the body of the loop, representing local variables declared in that lexical scope. The conventional C++ approach would be to insert destructor calls for any ğ“ptrs prior to taking the backwards branch. There is, however, a way to extend the lifetimes of these local values beyond the body of the loop if we wanted to allow the possibility of automatic lifetime extension beyond the body of the loop, which would be to insert those destructor calls only on the backwards branch, which would potentially allow an ğ“ptr to escape the loop.

### Lifetimes ending simultaneously

It is possible for a collection of lifetime constraints to require two or more variables to end their lifetimes at the same point in the program. (Most trivially: `Aâ‰¼B` and `Bâ‰¼A`) If all members, or all but one member, of this collection have trivial destructors, the non-trivial destructor call may be placed first at the required point followed by the trivial destructor calls (in any order) and the analysis will treat the constraints as satisfied. If two or more members of the set have non-trivial destructors, then compilation fails.

## Borrows

In addition to lifetime constraints there is a second category of constraints that we refer to in this document as borrows. There are three kinds of borrow. First, there is the shared borrow. A shared borrow of y by x is written `xâŠ£y`. A mutable borrow of y by x is written `xâ©¤y`. Finally, a transitive borrow relation is written `xâ«¤y`. The borrow is said to be active if it is within the lifetime of the item on the left side of the expression, for generic values, or if the name on the left side remains accessible for ğ“ptr and ğ’¹ptr variables. The item on the left side of the relationship is called the source of the borrow while the object on the right side is called the target of the borrow.

Intuitively, the meaning of these relation is that `xâŠ£y` indicates x being able to access y, but within the limits of a shared view. `xâ©¤y` indicates x being able to access y mutably.

### Syntactic properties

All of the borrow constraints are transitive within their own class. In detail, Whenever a constraint of the form `xâŠ£y` is added to the analysis, additional constraints of the form `xâŠ£z` should also be added for each existing constraint of the form `yâŠ£z` and additional constraints of the form `zâŠ£y` should also be added for each existing constraint of the form `zâŠ£x`, and the same goes for â©¤ and â«¤. These constraints are also monotonic, meaning that once a borrow constraint has been added to the analysis, it is never removed. (But remember that a pointer is only suppressed when the values on the left hand side of a borrow constraint are alive.)

`aâ©¤b` generates `aâŠ£b`.

`xâ«¤y` also propagates both shared and mutable borrow constraints through it transitively. In particular: `aâŠ£b` and `bâ«¤c` generates `aâŠ£c`, `dâ«¤e` and `eâŠ£f` generates `dâŠ£f`, and so on.

### Exclusivity

Two active mutable borrows to the same target, or an active mutable borrow and one or more active shared borrows (from different variables than the mutable borrow -- a shared and mutable borrow on the same entity from the same entity is acceptable), are a constraint violation that causes compilation to fail unless there is a chain of borrows between them. More specifically:

bâ©¤a and câ©¤a is a constraint violation unless bâŠ£c or câŠ£b or at least one of c and b is not alive.
bâ©¤a and câŠ£a is a constraint violation unless b=c or bâŠ£c or câŠ£b or at least one of c and b is not alive.

### Borrows and members

Borrow constraints may exist between the members of an object on either, or both, sides of the constraint expression. `x.yâŠ£z` implies `xâŠ£z` for all members y of x. `aâŠ£b` implies `aâŠ£b.c` for all members c of b. The same rules also apply for mutable borrows and the transitive borrow relation. An active mutable borrow targeting an object as a whole is incompatible with a mutable borrow or shared borrow from another source on any member of the object because of the `aâ©¤b` to `aâ©¤b.c` implication, which would conflict with a hypothetical `dâ©¤b.c` borrow.

Interestingly, the `.y` in `x.y` cannot be modeled as a function that takes the pointer x to a pointer to member y (in other words, something like the LLVM GEP operation). To model it in that way, we would have to answer the question of whether the result of the .y function mutably borrows from x or not (as x.y would be a function call, not a name to be related by a borrow). If it does, then no other member could be used to access x while the result of the .y function is available, which is extremely restrictive. If it does not, then x will remain free to be used as the source of a second .y function, producing two mutable borrows to the same item, which is unsafe. Note that in the current form of the language, you cannot write a getter function that works like direct member access using the default function constraints, which will always generate a `â…€â©¤x` constraint even if the return value was manually marked `â„›â©¤x.y` (see below).

Could this be fixed? Probably, but it would potentially add a great deal of complexity to the language, and it is already quite complex. The obvious possibility is to annotate some borrows with a "path" of how the borrow was made, and allow borrows from "non-overlapping" paths to exist to the same target without violating exclusivity. For example, the borrow of the .y function would be marked as "via y" in some way, and it would thus not conflict with a borrow "via z". (But don't ask me how transitivity is going to work once there is a chain involving two or more of these.)

### Borrows and pointers

In many ways the interaction between borrow constraints and the content of pointers is much the same as that between such constraints and the content of containers, so the rules described here can also be used as a model for explicitly writing those constraints.

When pointer assignment a = b is made, it generates the constraint `aâŠ£b`, which means, given the transitive rule described above, that pointer a also suppresses, transitively, anything that b does. If a is an ğ“‚ptr, ğ“ptr, or ğ’¹ptr, it also generates `aâ©¤b`. Finally, it also generates the transitive constraint `bâ«¤a`.

When a value, y, is stored into an ğ“ˆptr pointer, x, the constraint `xâŠ£y` is generated. If that value is stored into an ğ“‚ptr the constraint `xâ©¤y` is generated.

When a value, y, is loaded from an ğ“ˆptr pointer, x, the constraints `yâŠ£x` and `xâ«¤y` are generated. If an ğ“‚ptr value y is loaded from an ğ“‚ptr the constraints `yâ©¤x` and `xâ«¤y` are generated (note that an ğ“‚ptr cannot be loaded from an ğ“ˆptr).

### Borrows and function calls

In most ways the rules for borrow constraints and function calls are similar to those for lifetime constraints. Namely: When finishing analysis of a function, any borrow constraints not involving the parameters and/or the return value (or a member of a struct-type parameter or return value) should be discarded. If they involve a lifetime or variable on the left-hand side of the relationship that does not escape the function, the left hand side of the expression should be replaced with â…€ (abusing the notation slightly). If they involve a lifetime or variable on the right-hand side that does not escape the function, the constraint should be discarded. All of the remaining borrow constraints must be contained in the constraint list (`âŸª âˆ¥ ... âŸ«`) that is part of the declaration of the function, or be generated by one of the expressions contained in that list, or be implied automatically by the function call (for the sake of brevity â…€â©¤x is assumed for all ğ“‚ptr, ğ“ptr, and ğ’¹ptr parameters x and â…€âŠ£x is assumed for all ğ“ˆptr parameters x). If any are missing, compilation fails.

At a call site to the function, all borrow constraints contained in the function's constraint list (`âŸª âˆ¥ ... âŸ«`) are added to any existing constraints in the calling function (substituting in the names of the variables passed as parameters and the name that the return value is assigned to as appropriate). Constraints that have â…€ on the left hand side have it substituted with the lifetime of the function call (which is, in textual terms, the line break after the function call between it and the next expression). This essentially means that no conflicting borrows may be active while the function is executing, but it will not otherwise conflict with borrow constraints. If there are expression within the function's constraint list, any borrow constraints that would be generated by the evaluation of those expressions are also added. At this point if the constraints are inconsistent (by violating exclusivity, for example), compilation fails, with the exception that exclusivity conflicts between constraints that have â…€ on the left hand side and other constraints generated by the function call are ignored, but they can conflict with each other. (Practically, we can break the call of the function into two stages at the call site. The first stage is what the lifetime of â…€ covers and it is the point where constraints involving â…€ on the left-hand side of the relationship are added. Then, at the second stage, the remaining constraints generated by the function are added, but the lifetime â…€ resolves to does not cover this point.)

An early return from a function can be modeled as a Î¦ statement (see below) of the variables returned.

### Borrows and `if`s

As with lifetime constraints, the constraints from the two branches of the `if` construction should be merged afterwards. If this results in inconsistent constraints, then compilation fails. For every Î¦ statement in the form `a = Î¦(b,c)` the borrow constraints `aâ«¤b`, `aâ«¤c`, `bâ«¤a`, and `câ«¤a` are generated (which basically just transfers the constraints from b and c to a, so this can also be done by copying all borrow constraints involving b and c and substituting a for b and c.

### Borrows and loops

As with lifetime constraints, the Î¦ statements at the beginning of the block that is the body of a loop are handled as part of the two passes that are already done for lifetime constraints. In the first pass they are given just the transitive borrow constraints for the variable that comes from outside the loop. At the start of the second pass, any borrow constraints generated by the first pass for the variable in the loop are transferred to the variable that is the target of the Î¦ statement, and then all other borrow constraints from the first pass are discarded. If the second pass does not reveal any constraint violations, the loop passes the analysis.

### Note on semantic intent

The intent of borrow constraints is to express the existence of one or more "views" of a value. Mutable access to a value via a pointer that aliases one or more other pointers is a safety violation. As with any such semantic rules, borrow constraints are overly restrictive. In particular, their monotonic nature typically means that once an object on the left side of a borrow relation is put into a container, it will remain borrowed and unavailable until the lifetime of the container itself ends (insertion into the container is expressed as the container borrowing the inserted value, which then makes the container transitively borrow everything that the value was borrowing).

## A fork in the road: do we need lifetime constraints?

There is a plausible rule that can be added to the above section: if `aâŠ£b` or `aâ©¤b` then b outlives a (`Â§aâ‰¼Â§b`) if you also guarantee that the borrow constraints can only be generated targeting a living object. This is because once a borrow exists targeting b, the exclusivity rules would generally prevent b's destructor from running, meaning that it can't be destroyed while a is alive, meaning that it must be alive while a is alive. Of course, this also requires a's lifetime not to have any "holes" such that b could be destroyed while a is not considered alive (not that such a thing would be easy to generate).

If you admit this rule, then you may not need the ability to express lifetime constraints independently, as you could instead let `aâŠ£b` stand in for `Â§aâ‰¼Â§b`. And once you have that rule, it is easy to extend/abuse the notation to work on lifetimes as well, letting `LâŠ£M` stand in for `Lâ‰¼M`. This is very neat and simplifies the language. It also reduces the number of constraints you might have to write, since âŠ£ now does the work of â‰¼ as well.

I have not chosen to adopt this rule here, however, in order to simplify the rules around borrowing constraints. The borrow constraint is used here not just to mean "a pointer to"; it is also used to track pointer loads. Specifically, loading an ğ“‚ptr out of an ğ“‚ptr `b` and storing it in `a` generates `aâ©¤b`. This is not because `a` has a mutable view of `b` (although it may have a transitively mutable view on things that b itself has a mutable view of, which the transitivity rules of the constraint captures), but because adding the borrow constraint prevents that pointer from being loaded out of `b` again (since a load has the `â…€â©¤x` constraint as `b` is itself an ğ“‚ptr, and it must load *as* an ğ“‚ptr (and not via a cast to an ğ“ˆptr) since a mutable pointer cannot be loaded from an ğ“ˆptr). However, it is fine in this instance for the lifetime of `b` to end while `a` perhaps remains a valid pointer to something that `b` perviously pointed to. This is possible because `b` is a simple value (a pointer) and does not need to have a destructor function called on it. 

Adding such a rule also conflates an object being *able* to access something with actually accessing it. This isn't an issue in many cases. When a container or other object contains dead references, usually nothing is lost by disposing of the container at that point, since there isn't much that can be safely done with it. However, it makes the semantics of the destructor in particular almost impossible to express. Since the container may borrow its contents, we may have containerâŠ£contents, and thus Â§containerâ‰¼Â§contents, and so the container must be destroyed prior to its contents *even if the destructor has no need to read from those contents*.

The rest of this document *does not* follow this fork. Instead it explores what the pseudo-language would look like without this compromise and what can be done to simplify it without adding the additional rule.

## Other pointer rules

### Pointer conversion

Pointers may be converted from one type to another (i.e. may be cast from one pointer type to another) safely given the following restrictions: 

| From         |    To          |  Constraints generated    | Other restrictions                                |
| ------------ | -------------- | ------------------------- | ------------------------------------------------- |
| ğ“ptrâŸªTâŸ« x     |  ğ“‚ptrâŸªU, LâŸ« y | `Lâ‰¼Â§x`, `yâ©¤x`, and `xâ«¤y` |  T is a subtype of U or T = U                     |
| ğ“ptrâŸªTâŸ« x     |  ğ“ˆptrâŸªU, LâŸ« y  | `Lâ‰¼Â§x` and `yâŠ£x`          |  T is a subtype of U or T = U                    |
| ğ“‚ptrâŸªT, LâŸ« x |  ğ“‚ptrâŸªU, MâŸ« y | `Mâ‰¼L`, `yâ©¤x`, and `xâ«¤y`  |  T is a subtype of U or T = U                     |
| ğ“‚ptrâŸªT, LâŸ« x |  ğ“ˆptrâŸªU, MâŸ« y  | `Mâ‰¼L` and `yâŠ£x`           | T is a subtype of U or T = U                     |
| ğ“ˆptrâŸªT, LâŸ« x  |  ğ“ˆptrâŸªU, MâŸ« y  | `Mâ‰¼L` and `yâŠ£x`           | T is a subtype of U or T = U                     |
| ğ“‚ptrâŸªT, LâŸ« x |  ğ“ptrâŸªTâŸ« y     | `Â§yâ‰¼L`, `yâ©¤x`, and `xâ«¤y` | y must be an ğ“ptrâŸªTâŸ« when it becomes inaccessible |

Additional note on casting and subtypes: Being able to cast to a parent type could potentially escape any constraints that the subtype imposes on certain states being impossible (the same goes for accessing members of a struct directly). Thus, in the pseudo-language as defined, all types must support being in any possible state. In a real language, this could be avoided by making members, and the parent type if necessary, private so that casting to the parent type/accessing members is impossible if some states of those objects are not supported by the type.

Note on ğ“‚ptr and ğ“ptr to ğ“ˆptr casts: if these casts are modeled as a function call, then they will need a special exception to the rules. By being passed to a function, the constraint â…€â©¤x will be generated for the pointer that is the source of the cast. And this would mean that such a pointer could only be cast to an ğ“ˆptr once, as future casts would conflict with the existing borrow targeting it. Only the constraint â…€âŠ£x should be generated on the source pointer as part of such a cast if it were to be expressed as a function. (Why isn't this a more general problem? Because if â…€â©¤x would be an issue, the function can simply take x as an ğ“ˆptr.)

### Loads and stores

An ğ“‚ptr cannot be loaded from an ğ“ˆptr (and an ğ“ptr definitely can't be, since they can't be stored at all). I emphasize this to start with because it is an important rule to remember when writing unsafe code that is "pointer like" in allowing the retrieval of some stored object: you should not be able to get an ğ“‚ptr out without putting an ğ“‚ptr to the containing object in (unless aliasing is being prevented at runtime via a mutex, for example). Secondly, remember that only simple values are *values* in this pseudo-language, so you cannot load a struct from a pointer; only loads from pointers to the struct's simple members are possible.

With those caveats, the general signature for `load` is `auto loadâŸªT, L âˆ¥ â…€â‰¼L, â„›âŠ£x, xâ«¤â„› âŸ«(ğ“ˆptrâŸªT, LâŸ« x) -> T` and `auto loadâŸªT, L âˆ¥ â…€â‰¼L, â„›â©¤x, xâ«¤â„› âŸ«(ğ“‚ptrâŸªT, LâŸ« x) -> T` (although the borrows for the return value should only be generated when loading a pointer; loading integers, booleans, and enums doesn't generate borrows); the general signature for `store` is `void storeâŸªT, L âˆ¥ â…€â‰¼L, xâ©¤v âŸ«(ğ“‚ptrâŸªT, LâŸ« x, T v)`. If T is not a simple value, then it must be hidden behind a pointer, and thus there are no loads and stores for it directly. If the pseudo-language were a real language, the role would be filled with automatically generated copy constructor, copy assignment, and destructive move functions.

### ğ“ptr and ğ’¹ptr rules

The ğ“ptr and ğ’¹ptr types have some additional rules, beyond those already noted in this document. When an ğ“ptr or ğ’¹ptr is passed to a function call it is flipped to its complementary type (an ğ“ptr becomes a ğ’¹ptr, and vice versa) after that call. *Within* a function call, any ğ“ptr and ğ’¹ptr parameters must be flipped to their complementary types at all exits from the function. Any ğ“ptr or ğ’¹ptr variables declared within the function must be ğ’¹ptr types when the variable stops being visible (generally, when the scope it was declared in ends). The compiler may achieve this by calling the destructor of those variables (in the standard destructor order that C++ normally guarantees), assuming that there are no active borrow constraints that would make that impossible (the compiler may be allowed to attempt to solve these constraint issues by recursively ending the lifetimes of the source of the constraints if possible). Likewise, the compiler may attempt to convert a ğ’¹ptr into an ğ“ptr by calling the appropriate default constructor if compilation would otherwise fail.

ğ“ptr and ğ’¹ptr types are passed as parameters to express the semantics of constructors, destructors, and destructive moves. A ğ’¹ptr is passed to a constructor and the object becomes live within it, while an ğ“ptr is passed to a destructor to manage ending the object's lifetime. A destructive move takes both an ğ“ptr and a ğ’¹ptr parameter and simultaneously ends the lifetime of one object while starting that of the other.

Of course, this ultimately leaves us with the question of how ğ“ptr and ğ’¹ptr types are changed within such a function. And to answer that question we have to do away with a simplification that has been useful so far: for structs there are no ğ“ptr and ğ’¹ptr types as such. Rather, what we have been calling an ğ“ptr or ğ’¹ptr to a struct is really an aggregate of liveness tracking data tracking the liveness of each member individually (or, you could think of it as an aggregate of ğ“ptr and ğ’¹ptrs to the members of the struct -- but please don't implement it that way). What we have been calling an ğ“ptr is really one of these types where all the members are marked as alive, and a ğ’¹ptr is one where all the members are marked as dead. So, the solution to how an ğ“ptr switches its type for a struct is: recursively. Each member's ğ’¹ptr must be turned into an ğ“ptr by calling a function consuming a ğ’¹ptr (i.e. a constructor or value assignment) for each of its members. (And I assume that the compiler provides constructors, destructors, and destructive moves for the simple types that all structs must eventually reduce to.) 

I am unable to come up with a non-hideous syntax for a pointer to a struct that is partly alive and partly dead, and so have only provided the ability to talk about structs that are all alive or all dead in the pseudo-language, but this is not an intrinsic limitation of the semantics.

## Other notes

### Miscellaneous UB cleanup

UB must be eliminated from the safe subset. Much of that is already covered by the analysis rules that prevent errors in handling lifetimes, but there are still some corner cases that will need to be taken care of. Most notably, signed overflow for arithmetical operations. While the solution that Rust takes is to pretend that it crashes the program, although it can only enforce this in debug builds, it may be wiser to simply say that signed overflow is implementation defined in the context of Safe C++. At the very least, some data should be gathered demonstrating that the lost optimization potential is more than measurement noise.

### Exceptions

The pseudo-language is loudly silent on the matter of exceptions, which is because exceptions are complicated. Preliminary reflection suggests that if exceptions are to be supported in Safe C++, all safe functions that can throw will have to exhaustively list all the objects that they could throw (and thus a function that does not either catch or declare an exception type that some function it calls could possibly throw could be caught at compile time). This list of possibly thrown exceptions will have to be added to the type of all function pointers and function objects. Unsafe functions not marked as `noexcept` will have to be invisibly wrapped with some shim to catch any exceptions that they do throw and terminate the program. That done, an exception--caught or otherwise--could be analyzed as a forward branch from the throwing function to either the catch handlers or the exit of the containing function (as throwing an exception could then be translated into the pseudo-language as a function returning a variant type followed by a test for the type returned and the appropriate control flow based on that).

### Function types

A function type must include the safety constraints it generates, because it is only safe to cast from a function type that generates a strict superset of those constraints (a function that requires/generates more constraints cannot be called in place of one that requires/generates fewer). Without this limitation you get the famous Rust bug (still unsolved as of writing this document) https://github.com/rust-lang/rust/issues/25860 that arises because of not tracking the constraints (at least, according to the author of the report; I am not a Rust expert). Further notes on when it is safe to cast from one function to another are also found in the *Conversion between types differing only in lifetimes* section below.

This may mean that it will become necessary to name the set of constraints a function generates in order to propagate them. The notation to do that could clearly become quite hairy quite quickly. In some situations we could propagate the constraints implicitly. For example:
```
auto mapâŸªU, F âˆ¥ f(Îµ(ğ“ˆptrâŸªTâŸ«)) âŸ«(ğ“ˆptrâŸªsome_container_ofâŸªTâŸ«âŸ« self, F&& f) -> some_container_ofâŸªUâŸ«;
```
Here we don't have to name the constraints that the function/function-like-object passed in as f generates in order to make map share them because we can indirectly forward those constraints by putting the expression `f(Îµ(ğ“ˆptrâŸªTâŸ«))` in map's list of constraints. But what if we did need to name them? Until something better comes along, I will assume that we have a generic type that represents a function called `func` that takes the constraints as its first parameter (modeling the set of constraints, collectively, as a single compile-time constant value) and the function return type and parameter types as the remaining parameters. And, to make this work, we must assume that the name of the constraints may be inserted into a list of constraints with the meaning that all the constraints bound by that name are to be added to the other constraints in that list. Then we could define a function such as:
```
auto mapâŸªT, U, C âˆ¥ CâŸ«(ğ“ˆptrâŸªsome_container_ofâŸªTâŸ«âŸ« self, funcâŸªC, U, ğ“ˆptrâŸªTâŸ«âŸ« f) -> some_container_ofâŸªUâŸ«;
```
This function takes a funcâŸªC, U, ğ“ˆptrâŸªTâŸ«âŸ«, a function returning a U with an ğ“ˆptrâŸªTâŸ« argument and generating constraints C, and itself has those constraints in its constraint list. Ugly, but functional.

### Type instantiation and implementations 

The pseudo-language involves a large number of template instantiations, and many types and functions that were not templates previously may need to become templates in order to accommodate additional lifetime parameters. A naive implementation in an existing compiler could produce very poor results as it would create large numbers of types and functions for different variations of lifetime parameters. Mitigating this relies on two observations. First, lifetime parameters only affect the safety analysis, they do not affect code generation. Thus, types and functions that vary only via lifetime parameters can resolve to the same code on the backend. Secondly, most types created in this way will have lifetimes that only make sense within the function being analyzed, and so could be discarded afterwards. This suggests an implementation strategy where, for the analysis pass, very lightweight types are created to perform the analysis that simply refer to the lifetime-less types they will ultimately resolve to and discarding those lightweight types after the analysis pass. Furthermore, once a function has been compiled once, any future instantiations that differ just by lifetime parameters need only to have the analysis pass run, and can refer to the results of the previous compilation for the generated code.

## Extensions and additional work

There are a number of areas that are obvious targets for improvements but which are not required for the semantics described here to function.

### Reducing pointer lifetime annotations

Because ğ“‚ptr and ğ“ˆptr types both require an additional lifetime parameter, and this makes working with them verbose, it is desirable to hide that lifetime parameter as much as possible. The obvious choice is to default them to â…€, which would require the object that is the pointer's target to live as long as the pointer variable (or the structure that the pointer is contained in, for member variables). This choice, however, may lead to things such as `[[unsafe::drop_only(T)]]` and the `__phantom_data` type (as described in the Safe C++ proposal) being necessary, as it becomes hard to describe using the pointer value (to call its trivial destructor) without the necessity of using the object pointed to, a situation in which the lifetime of the pointer variable is longer than the lifetime of the target. As illustrated in examples below, the verbose syntax here can be used by the analyzer deduce that such operations are safe without additional annotations. But, as also illustrated by the examples below, â…€ is usually what is given to these lifetime parameters when not writing generic function parameters.

### Conversion between types differing only in lifetimes

Adding lifetime parameters to types generally produces the need for more function templates. Instead of a function taking a ğ“ˆptrâŸªvectorâŸªğ“ˆptrâŸªintâŸ«âŸ«âŸ« parameter (a pointer to a vector of pointers to ints), you might instead find yourself writing a function that takes a ğ“ˆptrâŸªvectorâŸªğ“ˆptrâŸªint, FâŸ«âŸ«, â…€âŸ«. The â…€ (the lifetime of the function) is ugly, but isn't too bad, and may even be deduced (for example, as described above). In any case, it doesn't require a template. But the F in that type does, because it is a generic lifetime parameter. Now, what you really need for the function is maybe only an ğ“ˆptrâŸªvectorâŸªğ“ˆptrâŸªint, â…€âŸ«âŸ«, â…€âŸ«: a vector of pointers to integers that themselves are alive during the function call, which would not require a template. However, a vectorâŸªğ“ˆptrâŸªint, â…€âŸ«âŸ« is very specific, and the vectors you have at the call site are unlikely to contain pointers that live exactly as long as the function call, which is what the parameter requires.

There are a few possible fixes for this. You could add overloaded constructors to vector specifically for vectors that contain pointers to allow converting a vector containing longer lived pointers to one containing shorter lived pointers automatically. Unfortunately, this has the dual drawbacks of possibly creating additional temporary vectors *and* that it won't extend to vectors storing non-pointer types with lifetime parameters (string_views, for example).

We might consider a language extension, saying that types with longer lifetimes should be considered super-types of those with shorter lifetimes, thus allowing a ğ“ˆptrâŸªvectorâŸªğ“ˆptrâŸªint, FâŸ«âŸ«, â…€âŸ« to be treated as a ğ“ˆptrâŸªvectorâŸªğ“ˆptrâŸªint, â…€âŸ«âŸ«, â…€âŸ« if F outlives the function. While this is a very nice solution, it doesn't always work. If you have a functionâŸªğ“ˆptrâŸªint, AâŸ«(ğ“ˆptrâŸªint, BâŸ«)âŸ« you can't substitute a functionâŸªğ“ˆptrâŸªint, CâŸ«(ğ“ˆptrâŸªint, DâŸ«)âŸ« for it if C and D outlive A and B. It works fine for the return type, but breaks for the parameter. If you call a functionâŸªğ“ˆptrâŸªint, AâŸ«(ğ“ˆptrâŸªint, BâŸ«)âŸ« you only have to provide it with a parameter that outlives B. However, if this call site is ultimately passed a functionâŸªğ“ˆptrâŸªint, CâŸ«(ğ“ˆptrâŸªint, DâŸ«)âŸ«, that function is only safe if its parameter lives as long as D, which is longer than B. Thus, calling it with a parameter that only lives as long as B is unsafe, and so the type conversion that permitted this is unsafe.

Rust ultimately goes with the above approach by adding additional rules to the language about how, in their terms, lifetimes are deduced to be either co- or contra- variant. C++ has other options. We are already familiar in C++ with defining specialized constructors to define the set of legal conversions. That pattern could be extended here if we could avoid making the pointer type to pointer type cast (i.e. the reference type to reference type cast in the un-lowered language) require an unnecessary copy. This could be done either by some other type of annotation within class definitions indicating such safe conversions, or a syntax could be introduced for a function that converts the type of a pointer parameter and use that syntax to define the action of such safe conversion (there is already something like this in the pseudo-language given how a function call can change an ğ“ptr to a ğ’¹ptr, but it would need to be extended).

With that in place, a container such as vector could be written to define its in-place / direct-pointer conversions that extend the naively provided pointer-to-pointer cast logic as something like: `in_place_conversion: vectorâŸªTâŸ« -> vectorâŸªUâŸ« requires( in_place_convertibleâŸªT, UâŸ« );`. Verbose, but is expressive enough to cover a very wide range of applications. (Note that in_place_convertibleâŸªT, UâŸ« also requires T and U to be the same size, which holds for the cases we are talking about, but is more restrictive than being able to construct a U from a T.) 

### Automatic constraint deduction

The compiler knows the lifetime and borrow constraints that it needs to see in a function's âŸª âˆ¥ ... âŸ« list of constraints, which is why it can produce an error on compiling a function that cannot be guaranteed to be safe given their listed constraints. Thus, the compiler could equally well generate that list for us on compiling a function. Being able to type something like `auto` in that list could save *a lot* of annotating work. However, it also means that the compiler has to be able to see, and spend the time checking, the body of the function. Feasibility isn't obvious given the way that C++ compilers currently work. Yes, we could stuff every function into header files with inline, so this could be made to work, but it is actively fighting against the compilation process. In a better world, the compiler could analyze a .cpp file and save all the constraints it generates in the process somewhere for itself so that it can know what those constraints are in other places that use the function without us having to encode that information textually in the header file, which asks us not only to be manual scribes for information the computer is already able to figure out, but also invites the possibility of "dead" constraints -- those not actually needed by the function after changes to it -- persisting simply because changing the header files is forgotten or too much work.

### Better automatic lifetime extension

C++ contains some complex and easily misused rules about how binding to a reference may automatically extend the lifetime of certain objects. (I say easily misused based on the recent necessity of patching the standard to make it work for certain ranged for loops; there are probably other pitfalls still lurking.) Since the analysis essentially knows how long things need to live in order to make a function compile safely, the automatic lifetime extension rules could be simplified in Safe C++ to be essentially "as long as it has to live to make the function work".

### Making constexpr allocations easier

It would be useful to sometimes allow memory allocated during compilation as part of constexpr evaluation to be compiled into the program, while other such allocations definitely should not outlive the compilation process. Lifetime constraints give us a way to talk about and enforce that. By naming a lifetime that ends when compilation ends, it is possible to statically detect when a constexpr allocation is bound within that lifetime and when it may exceed it.

## Further reading:

Ferdowsi, Kasra 2023 *The Usability of Advanced Type Systems: Rust as a Case Study*
Weiss, Aaron, Olek Gierczak, Daniel Patterson, and Amal Ahmed 2019 *Oxide: The Essence of Rust*
Karl Naden, Robert Bocchino, Jonathan Aldrich, Kevin Bierhoff 2012 *A type system for borrowing permissions*
Robert DeLine and Manuel FÃ¤hndrich 2004 *Typestates for Objects*
John Boyland 2003 *Checking Interference with Fractional Permissions*

## Examples

### Iterator invalidation

```
// prototypes of some functions used
auto to_iteratorâŸªT, L âˆ¥ iâŠ£v, iâ‰¼LâŸ«(ğ“ˆptrâŸªvectorâŸªTâŸ«, LâŸ« v, ğ’¹ptrâŸªspan_iteratorâŸªTâŸ«âŸ« i) -> void;
auto empty(ğ“ˆptrâŸªspan_iteratorâŸªTâŸ«, â…€âŸ«) -> bool;
auto advance(ğ“‚ptrâŸªspan_iteratorâŸªTâŸ«, â…€âŸ«) -> void;
auto currentâŸªL âˆ¥ â„›âŠ£i, â„›â‰¼LâŸ«(ğ“‚ptrâŸªspan_iteratorâŸªTâŸ«, LâŸ« i) -> optionalâŸªğ“ˆptrâŸªT, LâŸ«âŸ«;

auto emplace_backâŸªT âˆ¥ vecâ©¤valâŸ«(ğ“‚ptrâŸªvectorâŸªTâŸ«, â…€âŸ« vec, ğ“ptrâŸªTâŸ« val) -> void;
auto push_backâŸªT âˆ¥ vecâŠ£valâŸ«(ğ“‚ptrâŸªvectorâŸªTâŸ«, â…€âŸ« vec, ğ“ˆptrâŸªT, â…€âŸ« val) -> void;

...

ğ“‚ptrâŸªvectorâŸªintâŸ«, â…€âŸ« v = ...;                             // assume the vector is given to us
ğ’¹ptrâŸªspan_iteratorâŸªintâŸ«âŸ« i = allocaâŸªspan_iteratorâŸªintâŸ«âŸ«();
to_iterator(v, i);                                        // constructs i, making it live 
                                                          // iâŠ£v, Â§iâ‰¼Â§v

while(!empty(i)) {
	auto it_result = current(i);                          // it_resultâŠ£i, it_resultâŠ£v
                                                          // Â§it_resultâ‰¼Â§i, Â§it_resultâ‰¼Â§v
	auto value_from_array = value_or(it_result, 0);
	if(load(value_from_array) % 2 == 0)                   // ok, type of pointer is ğ“ˆptrâŸªT, Â§iâŸ« and i is alive
		push_back(v, 2);                                  // conflicts with iâŠ£v and it_resultâŠ£v; compiler error
	advance(i);
}

```
This example also illustrates how important having a ranged for loop can be for clean and efficient safe code. Because the iterator may not have a valid position (e.g. it may have reached the end of its range or have been constructed with an empty range), a function that allows us to look at the current value cannot safely return a pointer unconditionally. It can return an optional, as the example above has assumed, which is only engaged when there is a value to look it. Or, it could take a function that it invokes with the view of the current object of the iterator only when one exists. Or the iterator could be rewritten to have a map-like function that it applies to all of its contents (if any). But no while loop can provide the guarantee that the iterator is in a valid state inside the loop. The compiler could, however, safely create a ranged for loop that uses an unsafe method internally to unconditionally access the view of the current item, assuming that it also generates a mutable borrow on the iterator for the duration of the loop, thus preventing us from meddling with the iterator, or anything it depends on, to invalidate it during the loop.

### Making a dangling reference

```
ğ“‚ptrâŸªvectorâŸªstring_viewâŸªâ…€âŸ«âŸ«, â…€âŸ« v = ...;                  // assume the vector is given to us
                                                          // string views are asserted as being good as long as the vector
														  // is accessible through this reference
														  
ğ’¹ptrâŸªstring_viewâŸªâ…€âŸ«âŸ« sptr_a = "string literal";           // Details of constructing a string_view omitted
                                                          // but this ought to be fine, as the literal has a lifetime of ğ•Œ
														  // creates sptr_aâŠ£"string literal"
														  
push_back(v, sptr_a);									  // Being in the same scope, the lifetimes are the same for both
                                                          // variables. Thus the implicit cast to an ğ“ˆptr passes analysis.
														  // creates vâŠ£sptr_a, vâŠ£"string literal"

{
	ğ’¹ptrâŸªstringâŸ« string_value =  ...;                      // we assume the constructor for the string is run here
	ğ’¹ptrâŸªstring_viewâŸªâ…€âŸ«âŸ« sptr_b;
	string_viewâŸªâ…€âŸ«(sptr_b, string_value);                  // constructs a view of the string
	                                                       // creates sptr_bâŠ£string_value
														   
	push_back(v, sptr_b);                                  // This line (should) fail to compile: the lifetime of sptr_b
	                                                       // is less than that of v, and so its â…€ resolves to a shorter lifetime,
														   // and, if safe, the string_view type would not allow that cast
}
```

So, to even put a reference into the vector that could dangle, we must relax the lifetime restriction. We can do that maximally by requiring no lifetime at all.

```
ğ“‚ptrâŸªvectorâŸªstring_viewâŸªâˆ…âŸ«âŸ«, â…€âŸ« v = ...;        	  
ğ’¹ptrâŸªstring_viewâŸªâ…€âŸ«âŸ« sptr_a = "string literal";           // creates sptr_aâŠ£"string literal"
push_back(v, sptr_a);									  // lifetime of sptr_a is greater than âˆ…, so this cast is possible
                                                          // creates vâŠ£sptr_a, vâŠ£"string literal"

{
	ğ’¹ptrâŸªstringâŸ« string_value =  ...;                   
	ğ’¹ptrâŸªstring_viewâŸªâ…€âŸ«âŸ« sptr_b;
	string_viewâŸªâ…€âŸ«(sptr_b, string_value);                  // constructs a view of the string
	                                                       // creates sptr_bâŠ£string_value
														   
	push_back(v, sptr_b);                                  // Now this line should compile because the lifetime of sptr_b
	                                                       // is also greater than âˆ…
														   // creates vâŠ£sptr_b, vâŠ£string_value
														   
	~string(string_value);                                 // compilation fails here, because the call implicitly
	                                                       // generates â…€â©¤string_value, which violates exclusivity
														   // But let us assume that it didn't for the moment, and that
														   // ~string doesn't mutably borrow from string_value (which it must
														   // to change the liveness of its contents)
}

for(auto s : v) {                                          // because I don't want to write out iterator details again ...
                                                           // Note that the Safe C++ proposal would fail to compile the code here
														   // since v borrows from a dead object and so cannot be used.
														   
	print(s);                                              // This line (should) fail to compile. At some point to print character
	                                                       // data must be loaded from the string_view, which will generate the
														   // constraint that the lifetime of the data pointed to includes the
														   // function call, which âˆ… does not satisfy.
}

```

### Tracking liveness

```
// prototypes of some functions used
auto get_contentsâŸªT, L âˆ¥ â„›â©¤pâŸ«(ğ“‚ptrâŸªboxâŸªTâŸ«, LâŸ« p) -> ğ“‚ptrâŸªT, LâŸ«;
auto get_contentsâŸªT, L âˆ¥ â„›âŠ£pâŸ«(ğ“ˆptrâŸªboxâŸªTâŸ«, LâŸ« p) -> ğ“ˆptrâŸªT, LâŸ«;
auto moveâŸªTâŸ«(ğ’¹ptrâŸªboxâŸªTâŸ«âŸ«, ğ“ptrâŸªboxâŸªTâŸ«âŸ«) -> void;

...

ğ’¹ptrâŸªboxâŸªstringâŸ«âŸ« string_ptr;
get_contents(string_ptr);                 // compilation fails: ğ’¹ptr cannot be cast to ğ“‚ptr

ğ’¹ptrâŸªstringâŸ« string_value =  ...;         // we assume the constructor for the string is run here
boxâŸªstringâŸ«(string_ptr, string_value);    // constructor for box, string_ptr is now an ğ“ptr
get_contents(string_ptr);                 // ok, ğ“ptr can be cast to ğ“‚ptr

ğ’¹ptrâŸªboxâŸªstringâŸ«âŸ« new_string_ptr;
move(new_string_ptr, string_ptr);         // calls the "move" constructor, flips the ğ“ptr and ğ’¹ptr parameters

get_contents(string_ptr);                 // compilation fails: string_ptr is a ğ’¹ptr again
```

### Trying to return a dangling reference

```
auto as_str(int x) -> ğ“ˆptrâŸªstring, â…€âŸ« {
    ğ’¹ptrâŸªstring, â…€âŸ« s;
	std::to_string(s, x);	// converts s to type ğ“ptrâŸªstring, â…€âŸ«
							// (note that â…€ in the declaration remains bound to the same lifetime value as before, 
							// which is the lifetime Â§s
	return s; 				// attempt to implicitly convert ğ“ptrâŸªstring, â…€âŸ« to ğ“ˆptrâŸªstring, Â§as_strâŸ«
							// this fails because ~string(s) must run before the function exits (see below)
}
```

```
auto as_str(int x) -> ğ“ˆptrâŸªstring, â…€âŸ« {
    ğ’¹ptrâŸªstring, â…€âŸ« s;
	std::to_string(s, x);
	~string(s);				// this converts s back to type ğ’¹ptrâŸªstring, â…€âŸ«
	return s;				// there is no ğ’¹ptr to ğ“ˆptr cast, so this fails to compile
}
```

Ok, so let's try another way to get this pointer out.

```
auto as_str(int x) -> ğ“ˆptrâŸªstring, â…€âŸ« {
    ğ’¹ptrâŸªstring, â…€âŸ« s;
	std::to_string(s, x);
	ğ“ˆptrâŸªstring, Â§as_strâŸ« ret_value;		// the pointer we want to return
	ret_value = s;						// This is provisionally legal; s could live as long as the function
										// thus, it is converted to an ğ“ˆptrâŸªstring, Â§as_strâŸ«
										// this creates the borrow constraint: ret_valueâŠ£s
										
	~string(s);							// This fails because ret_valueâŠ£s is active:
                                        //~string generates â…€â©¤s which conflicts with ret_valueâŠ£s
	return ret_value;					// And if ret_value was not alive for the previous line, it could not be returned here
}
```

Even assuming that `auto as_str(int x) -> ğ“ˆptrâŸªstring, â…€âŸ«` could be made to compile, a function call such as `auto v = as_string(4);` wouldn't be very useful. The lifetime of the string pointed to by v would have expired before it could possibly be used. Thus, no function that does anything with strings could be called with v as a parameter. Any function that wants to view any of the values contained in the string object must either itself, or transitively, load values from that pointer (or derived member pointers, which will have the same lifetime). For example `auto print_str(ğ“ˆptrâŸªstring, â…€âŸ« x) -> void`, which might print a string to the console, requires that the string passed to it be alive at least as long as the function call itself. The return value of `as_str`, however, has only guaranteed that the returned pointer has lived as long as the function call that made it. By the time any subsequent statements are reached, its lifetime has expired, and thus it cannot be converted to ğ“ˆptrâŸªstring, Â§print_strâŸ« later because the lifetime Â§print_str is not constrained to fall within the time that Â§as_str guarantees.

So, what about trying to return something with a longer lifetime, like `auto as_str(int x) -> ğ“ˆptrâŸªstring, ğ•ŒâŸ«`. Well, the results would be an ğ“ˆptr to contents that live as long as the program does, so it will obviously be usable after the call. But, if we can't get an Â§as_str out in the obvious way, we certainly can't get something with a longer lifetime out. So, what if we do a double indirection? We make a mutable pointer to a pointer with a sufficiently long lifetime. Then, we store the pointer we want to get out in that mutable pointer, and it will be safely out of the way by the time ~string runs.

```
auto as_strâŸªLâŸ«(ğ“‚ptrâŸªğ“ˆptrâŸªstring, LâŸ«, â…€âŸ« i, int x) -> void {
    ğ’¹ptrâŸªstring, â…€âŸ« s;
	std::to_string(s, x);
	ğ“ˆptrâŸªstring, LâŸ« ret_value;	// we want to store this in i
	ret_value = s;				// This cast generates the Lâ‰¼Â§s constraint
	                            // it also generates ret_valueâŠ£s
	store(i, ret_value);		
	~string(s);					// s cannot be destroyed here because â…€â©¤s and ret_valueâŠ£s, but even ignoring that ...
}                               // at the end of compilation Lâ‰¼Â§s is widened to Lâ‰¼Â§as_str
                                // since this is not in the function's list of constraints, compilation would fail
```

Ok, so we can annotate our function with a constraint that would solve this: âŸªLâˆ¥Lâ‰¼Â§as_strâŸ«

```
auto as_strâŸªL âˆ¥ Lâ‰¼â…€âŸ«(ğ“‚ptrâŸªğ“ˆptrâŸªstring, LâŸ«, â…€âŸ« i, int x) -> void {
    ğ’¹ptrâŸªstring, â…€âŸ« s;
	std::to_string(s, x);
	ğ“ˆptrâŸªstring, LâŸ« ret_value;	// we want to store this in i
	ret_value = s;				// generates the Lâ‰¼Â§s constraint and ret_valueâŠ£s
	store(i, ret_value);		// this propagates the borrow constraint ret_valueâŠ£s resulting in iâŠ£s
	~string(s);					// so â…€â©¤s conflicts with iâŠ£s
								// i must live as along as Â§as_str because it is a parameter, so compilation fails
}
```

But what if the type in this function didn't need a destructor call; if it were an int, for example? Well, in that case, the function could compile. *But* it still remains safe. It can only be used with an ğ“ˆptrâŸªstring, LâŸ« where L extends to at most the end of the function call. Thus, no safe loads from the pointer inside i are possible after the function has returned, and there is no risk of peeking at the memory of an expired local.

### Use of an array 

```
ğ’¹ptrâŸªarrayâŸªint, 3âŸ«, â…€âŸ« data;
arrayâŸªint, 3âŸ«(data, 1, 2, 3); 						// constructor
ğ“ˆptrâŸªarrayâŸªint, 3âŸ«, â…€âŸ« view = data;       			// creates viewâŠ£data
auto element_view = arrayâŸªint, 3âŸ«.index(view, 0);	// creates element_viewâŠ£view, element_viewâŠ£data
arrayâŸªint, 3âŸ«.push(data, 4);							// â…€â©¤data conflicts with viewâŠ£data; compilation fails
return load(element_view);							// if the lifetimes of element_view and view had been
                                                    // ended to make the previous line compile, element_view
													// could not then be loaded
```

How the index function might be declared (assuming they crash on out of range indexes):
```
auto arrayâŸªT, sizeâŸ«.indexâŸªL âˆ¥ â„›âŠ£aâŸ«(ğ“ˆptrâŸªarrayâŸªT, sizeâŸ«, LâŸ« a, int i) -> ğ“ˆptrâŸªT, LâŸ«;
auto arrayâŸªT, sizeâŸ«.indexâŸªL âˆ¥ â„›â©¤a, aâ«¤â„›âŸ«(ğ“‚ptrâŸªarrayâŸªT, sizeâŸ«, LâŸ« a, int i) -> ğ“‚ptrâŸªT, LâŸ«;
```
Note that â„›âŠ£a in the first prototype doesn't do anything by itself; an ğ“ˆptr doesn't do anything when it suppresses another ğ“ˆptr, nor does being suppressed block the usage of an ğ“ˆptr. However, this propagates transitively, and is what ultimately generates the element_viewâŠ£data constraint in the analysis above.

### Building a better Iterator

This is a sketch for how unsafe code can be safely wrapped in an iterator interface to allow simultaneous mutable access to different elements of an array-like type even though the direct indexing functions that return ğ“‚ptrs must borrow from the array-like object, and hence cannot be used to get at different elements in the array at the same time.

Specifically, 
```
auto vectorâŸªTâŸ«.atâŸªL âˆ¥ â„›â©¤v, â…€â‰¼LâŸ«(ğ“‚ptrâŸªvectorâŸªTâŸ«, LâŸ« v, size_t index) -> optionalâŸªğ“‚ptrâŸªT, LâŸ«âŸ«;
```
The `â„›â©¤v` constraint means that this function cannot be called twice without discarding the return value of the first call prior to the second, as it would create two mutable borrows to the vector.

However, an iterator *should* be able to get around this. If we can make sure that the pointer to an element can only be retrieved once per position, then multiple values gotten out of the same iterator should be able to co-exist, as long as we take the appropriate precautions.

First, the iterator type itself.

```
struct mut_vector_iteratorâŸªTâŸ« {
	ğ“‚ptrâŸªvectorâŸªTâŸ«, â…€âŸ« vec;
	size_t position;
};
```

Its constructor:
```
auto mut_vector_iteratorâŸªT âˆ¥ selfâ©¤v âŸ«(ğ’¹ptrâŸªmut_vector_iteratorâŸªTâŸ«âŸ« self, ğ“‚ptrâŸªvectorâŸªTâŸ«, Â§selfâŸ« v) -> void {
	store(self.vec, v);
	store(self.position, 0);
}
```
Note that the lifetime of the pointed-to vector is constrained by this constructor. If someone uses this as say:
```
vec = ...;
ğ’¹ptrâŸªmut_vector_iteratorâŸªTâŸ«âŸ« it;
mut_vector_iterator(it, vec);
```
The necessary cast of the second parameter ensures that the lifetime of the vector pointed to by `vec` must outlive that of `it`. This is more than just the `selfâ©¤v` borrow constraint by itself does.

Now we can write the iterator's `next` function:
```
auto mut_vector_iteratorâŸªTâŸ«.nextâŸªM âˆ¥ â…€â‰¼M âŸ«(ğ“‚ptrâŸªmut_vector_iteratorâŸªTâŸ«, MâŸ« self) -> optionalâŸªğ“‚ptrâŸªT, MâŸ«âŸ« {
	auto old_position = load(self.position);  // â…€â‰¼M from the load (further generation of this constraint not noted)
	store(self.position, old_position + 1);
	
	auto vec = load(self.vec);
	auto ret_value = vectorâŸªTâŸ«.at(vec, old_position); // ret_valueâ©¤vec, vecâ©¤self.vec
	unsafe.break_borrows(ret_value);
	return ret_value;
}
```

So, using `unsafe.break_borrows` we have discarded the borrows that the returned value would normally have. But how can we know that it is safe to do that? Well, first we have guaranteed that the vector outlives the iterator object. The iterator object holds a mutable borrow of the vector, so no more iterators or other access functions can get at elements in the vector without going through the iterator (nor can the vector reallocate or otherwise invalidate its elements). Assuming that we provide no other functions that could "back up" the iterator, the iterator itself can only provide access to each element once. And by ensuring that the returned value's pointer has a lifetime equal to the iterator itself, which is necessarily outlived by the vector, we know that the vector backing the element remains alive and in place while that pointer is usable. 

### One way to consume the contents of a box

```
// C = type of the constraints
auto boxâŸªTâŸ«.mapâŸªU, C âˆ¥ CâŸ«(ğ“ptrâŸªboxâŸªTâŸ«âŸ« self, funcâŸªC, U(ğ“ptrâŸªTâŸ«) âŸ« f) -> U { 
// or
auto boxâŸªTâŸ«.mapâŸªU, F âˆ¥ f(Îµ(ğ“ptrâŸªTâŸ«)) âŸ«(ğ“ptrâŸªboxâŸªTâŸ«âŸ« self, F&& f) -> U { 
       // need a specialization for functions returning void as well, of course

	auto v = self.ptr    // self.ptr is assumed to be a C pointer here 
	auto pv = unsafe.castâŸªğ“ptrâŸªTâŸ«âŸ«(v);
	
	ğ’¹ptrâŸªUâŸ« result;
	result = f(pv);      // do the mapping -- ends lifetime of contained object, starts lifetime of result object
	
	usafe.free(v);
	unsafe.forget(self); // forget flips the ğ“ptr to a ğ’¹ptr without calling any destructors
	
	return result;
}
```